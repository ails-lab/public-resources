<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset='utf-8'>
    <script src='https://www.w3.org/Tools/respec/respec-w3c' async class='remove'></script>
    <script class='remove'>
        // All config options at https://respec.org/docs/
        var respecConfig = {
            // Working Groups ids at https://respec.org/w3c/groups/
            group: "webapps",
            specStatus: "unofficial",
            editors: [{
                name: "Alexandros Chortaras",
                url: "https://www.ece.ntua.gr/en/staff/217",
            }],
            shortName: "d2rml",
            // See https://respec.org/docs/#xref for usage.
            xref: "web-platform",
        };
    </script>
	<style>
	
	</style>
</head>

<body>
    <h1 id="title">Data to RDF Mapping Language (D2RML)</h1>
    <section id='abstract'>
        <p>This document describes D2RML (Data-to-RDF Mapping Language), as an extension of the R2RML mapping language, which significantly enhances its abilities to collect data from diverse data sources and transform them into custom RDF graphs.</p>
		
    </section>
    <section id='sotd'>
			<p><i>This document is under elaboration, it is subject to change and may provide an incomplete presentation of certain aspects of D2RML.</i></p>
    </section>

    <section>
        <h2 id="introduction">Introduction</h2>
        <p>This document describes D2RML, a language for creating RDF datasets from heterogeneous datasets. The main mechanism of obtaining RDF data from a dataset is a mapping. Such mappings allows the orchestrated retrieval of data from several information sources, their transformation and extension using relevant web services, their filtering, restructuring and manipulation using simple operations, and finally their mapping to RDF datasets.</p>
		
		<p>D2RML mappings are themselves expressed as RDF graphs and written down in <a href="link-to-TURTLE">Turtle syntax</a> [[TURTLE]].</p>
        <section>
            <h2 id="document-conventions">Document Conventions</h2>
            <div>
                <p>In this document, examples assume the following namespace prefix bindings unless otherwise stated:</p>
				
                <table class="def" id="tab-namespaces" rules="all" summary="list of prefixes used in the document">
                    <caption>Table 1: Namespaces used by this document.</caption>
                    <thead>
                        <tr>
                            <th><strong>Namespace prefix</strong></th>
                            <th><strong>Namespace URI</strong></th>
                        </tr>
                    </thead>				
                    <tbody>
                        <tr>
                            <td><code>cnt</code></td>
                            <td><code>http://www.w3.org/2011/content#</code></td>
                        </tr>							
                        <tr>
                            <td><code>dr</code></td>
                            <td><code>http://islab.ntua.gr/ns/d2rml#</code></td>
                        </tr>
                        <tr>
                            <td><code>dris</code></td>
                            <td><code>http://islab.ntua.gr/ns/d2rml-is#</code></td>
                        </tr>
                        <tr>
                            <td><code>drop</code></td>
                            <td><code>http://islab.ntua.gr/ns/d2rml-op#</code></td>
                        </tr>
                        <tr>
                            <td><code>enc</code></td>
                            <td><code>http://islab.ntua.gr/ns/enc#</code></td>
                        </tr>							
                        <tr>
                            <td><code>ff</code></td>
                            <td><code>http://islab.ntua.gr/ns/file-formats#</code></td>
                        </tr>
                        <tr>
                            <td><code>formats</code></td>
                            <td><code>https://www.w3.org/ns/formats/</code></td>
                        </tr>
                        <tr>
                            <td><code>http</code></td>
                            <td><code>http://www.w3.org/2011/http#</code></td>
                        </tr>								
                        <tr>
                            <td><code>rdf</code></td>
                            <td><code>http://www.w3.org/1999/02/22-rdf-syntax-ns#</code></td>
                        </tr>						
                        <tr>
                            <td><code>rr</code></td>
                            <td><code>http://www.w3.org/ns/r2rml#</code></td>
                        </tr>						
                    </tbody>
                </table>
            </div>
        </section>

    </section>

    <section>
        <h2 id="d2rml-overview">Overview of D2RML</h2>
		
		<p>D2RML is a language that allows the definition of data processing workflows that acquire data from one or more information sources (e.g. local files, HTTP APIs, relational database systems, SPARQL endpoints), interpret them based on their structure (e.g as relational tables, XML documents, JSON documents, plain text), split them in subelements (e.g. relation table rows, XML elements, JSON objects, regular expression matches), and iterate over the elements by applying at the same time mapping rules that generate out of the original content RDF triples or plain text lines. During iteration process, the data may be parameterically expanded by obtaining additional data from additional sources, so that the eventually the mapping rules may work over the expanded data.</p>
		
		<p>A D2RML specification takes the form of a D2RML document, which contains the full specification of one or more data processing workflows. A D2RML document is processed by a <a href="#dfn-d2rml-processor">D2RML processor</a>, which is responsible from interpreting the specification, retrieving the data from the source and generating the final RDF data. The output of processing a D2RML document is one or more files containing data in some RDF serialization. Apart from the generation of RDF data, which is the main purpose of a D2RML, a D2RML document may contain also mapping rules that generate plain text files; this might be useful for generating e.g. also SPARQL update statements.</p>
		
		<p>The core mechanism for generating RDF triples are the maps, which are rules for generating RDF terms (subjects, predicate, objects, named graphs), entire RDF triples, as well as plain text lines from the element of the data obtained from then information soures over which the iteration takes places.</p>
		
<!--		
		<p>A typical <a href="#dfn-d2rml-document">D2RML document</a> defines one or more <a href="#dfn-logical-dataset">logical datasets</a>, each one of which may represent either a <a href="#dfn-triples-dataset">triples dataset</a>, i.e. a readily available RDF dataset, or a <a href="#dfn-triples-map">triples map</a>, i.e. a set of rules for constructing an RDF dataset from other data.</p>
		
		<p>A triples dataset or triples map consumes data obtained from some <a href="#dfn-information-source">information source</a>. Before being fed to the triples dataset or triples map, the <a href="#dfn-data-block">data blocks</a> delivered by an information source are interpreted as a <a href="#dfn-logical-list">logical list</a>, which consists of one or more <a href="#dfn-logical-row">logical rows</a>. In turn. each logical row is considered to consist of several <a href="#dfn-logical-columns">logical columns</a>. The columns might be fixed, as in the case of a <a href="#dfn-logical-table">logical table</a>, or dynamically constructed from the logical row content, as in the case of a <a href="#dfn-logical-array">logical array</a>. The contents of each column in a logical row are addressed by a column name. Each column in a logical row may contain zero or or more values;  in general it is a <a href="#dfn-value-set">value set</a>.</p>
		
		<p>A logical row in a logical list may be extended by applying <a href="#dfn-function">functions</a> or <a href="#dfn-transformations">transformations</a>. These use the contents of existing logical column in the logical row any either be applying on them a in-line function or by using them to form requests to other information sources. in the first case, each function results in an extra for the logical row, while in the second case a transformation result in a new logical list; this logical list extends the logical row the new the logical columns that can be obtained from it. The extension mechanism can be recursive and apply e.g. a transformation on the results of other function or transformation applications.</p> 
		
		<p>Each logical list is mapped to an RDF dataset by a <a href="#dfn-triples-map">triples map</a>. The triples map is a rule that maps each logical row in the logical list to several RDF triples. The most common rule pattern has two main parts:
		
		<ol>
			<li>A <a href="#dfn-subject-map">subject map</a> that generates the subject of all RDF triples that will be generated from a logical row.</li>
			<li>Multiple <a href="#dfn-predicate-object-map">predicate-object maps</a> that in turn consist of <a href="#dfn-predicate-map">predicate maps</a> and <a href="#dfn-object-map">object maps</a>.</li>
		</ol>
		
		<p>A subject, predicate and object map refer to logical column to get their values. Triples are produced by combining the subject map with a predicate map and object map, and applying these three to each logical row. If in this combination value sets with more than one values are involved, all possible combinations among the values in the several values sets are considered.</p>
		
		<p>By default, all RDF triples obtained from a logical dataset are in the default graph of the <a href="#dfn-output-dataset">output dataset</a>. A logical dataset can contain <a href="#dfn-graph-map">graph maps</a> that place some or all of the triples into named graphs instead.</p>

		<p>The RDF triples obtained from a logical dataset, might not be sent to the <a href="#dfn-output-dataset">output dataset</a>, but to an <a href="#dfn-memory-store">memory store</a> that is a in-memory RDF dataset and may be used as an information source for <a href="#dfn-transformations">transformations</a>.</p>
-->		
	</section>
	
	<section id="information-sources">
		<h2>Information Sources</h2>
		
		<p>An <dfn id="dfn-information-source">information source</dfn> represents a data container. The description of an information source provides the details about the exact way access to the data that reside in the data container is achieved. Information sources eventually provide their data as <dfn id="dfn-data-block">data blocks</dfn>. A data block may be binary or textual data, and the information source may or may not be ignorant about the form of the data blocks it provides. The abstract class of all information sources is <a href="#dris:InformationSource"><code>dris:InformationSource</code></a>. In general, the description of an information source may be parametric, any such <a href="#dfn-parameter">parameters</a> are declared using the <a href="#dr:parameter"><code>dr:parameter</code></a> property.</p>
		
		<figure id="information-sources-diagram"><img src="information-sources.png" alt="Information Sources">
			<figcaption><span class="fig-title">Information source classes.</span></figcaption> 
		</figure>

		
		<p>Information sources are divided in two main classes: <a href="#dfn-data-source">data sources</a> and <a href="#dfn-service-source">service sources</a>.</p>
		
		<section id="data-sources">
			<h3>Data Sources</h3>
		
			<p>A <dfn id="dfn-data-source">data source</dfn> is an information source which represents one or more <a href="#dfn-data-block">data blocks</a>, typically a single data block, in a particular a file, that are obtained every time they are requested from the data source. A specific data source is a subclass of <a href="#dris:DataSource"><code>dris:DataSource</code></a> which is the abstract class of all data sources. An instance of a data source should contain the necessary information for interpreting the data blocks. If the <dfn id="dfn-file-format">file format</dfn> of the data block is important and cannot be determined correctly from a file extension that accompanies the data block, it may be specified by a <a href="#dris:fileFormat"><code>dris:fileFormat</code></a> property. The <dfn id="dfn-character-encoding">character encoding</dfn> of a textual data block may be specified by a <a href="#dris:characterEncoding"><code>dris:characterEncoding</code></a> property. If access to the data block is secured by a <dfn id="dfn-password">password</dfn>, the password may be specified by a <a href="#dris:password"><code>dris:password</code></a> property.</p>
		
			<p>Currently supported data sources are <a href="#dfn-file-source">file sources</a>, which represent local files, and <a href="#dfn-http-source">HTTP sources</a>, which represent remote files or data obtained though an HTTP request.</p> 
			
			<section id="sec-file-sources">
				<h4>File Sources </h4>

				<p>A <dfn id="dfn-file-source">file source</dfn> represents one or more files in the local file system on which the D2RML processor is executed and has direct access to. Is is an instance of <a href="#dris:FileSource"><code>dris:FileSource</code></a>. The physical location of the file is a <dfn id="dfn-path">path</dfn> and is specified by the <a href="#dris:path"><code>dris:path</code></a> property. More that one paths <em class="rfc2119">MAY</em> be provided, in which case the file source represents the set of data blocks corresponding to the individual files, rather than a singe data block.
			
				<p>A <a href="#dfn-path">path</a> <em class="rfc2119">SHOULD</em> be specified using <code>/</code> as separator, regardless of the underlying file system.<p>
			
				<div class="marker" id="ex-file-source-1">
					<pre class="example" title="A file source that represents the contents of two text local files having a particular character encoding."><code>
<#CSVFile>
   a dris:FileSource ;
   dris:path "c:/data/part-1.csv" ;
   dris:path "c:/data/part-2.csv" ;
   dris:characterEncoding enc:Windows-1253 .
					</code></pre>
				</div>
			
			</section>
			
			<section id="sec-http-sources">
				<h4>HTTP Sources </h4>
				
				<p>An  <dfn id="dfn-http-source">HTTP source</dfn> represents a single <a href="#dfn-data-block">data block</a> obtainable by an HTTP request. It is an instance of <a href="#dris:HTTPSource"><code>dris:HTTPSource</code></a>. If the request is a GET request, the full request URL can be specified using the <a href="#dris:uri"><code>dris:uri</code></a> property. More complex requests, such as POST requests, can be specified using the <a href="#dris:httpRequest"><code>dris:httpRequest</code></a> property whose object is an instance of <a href="https://www.w3.org/TR/HTTP-in-RDF10/#RequestClass"><code>http:Request</code></a>. If access to the data block   represented by the HTTP source is secured, the necessary credentials can be provided through the <a href="#dris:credentials"><code>dris:credentials</code></a> property.</p>
			
			
<!--			<p>If the source returns data in pages, where a page identifier (e.g. a counter) is part of the request, that counter can be specified as a parameter using the <a href="#dris:parameter"><code>dris:parameter</code></a> property and a <a href="#dris:RequestIterator"><code>dris:RequestIterator</code></a> to iteratively assign values to it and access all source pages.</p> -->

				<div class="marker">
					<pre class="example" title="Simple HTTP source using the GET method."><code>
<#HTTPSource>
   a dris:HTTPSource ;
   dris:uri "http://www.example.com/data/countries" .
					</code></pre>
				</div>			
			
				<div class="marker">
					<pre class="example" title="Complex HTTP source using the POST method."><code>
<#HTTPSource>
   a dris:HTTPSource ;
   dris:httpRequest [
      http:absoluteURI "https://www.example.com/api/analyze?type=image&language=en" ;
      http:methodName "POST" ;
      http:headers ( 
        [ 
          http:fieldName "Content-Type" ;
          http:fieldValue "application/json" ; 
        ]
        [ 
          http:fieldName "APIKey" ;
          http:fieldValue "A$2@3KZa" ; 
        ] 
      ) ;
      http:body [ 
        a cnt:ContentAsText ;
        cnt:chars "{\"url\" : \"http://www.example.com/data/image.jpg\" }" ; 
      ] ;
   ] .				
					</code></pre>
				</div>
			
			</section>
			
			<section id="sec-container-sources">
				<h4>Container Sources </h4>
				
				<p>A data source may act as a <dfn id="dfn-container-source">container source</dfn>, i.e. as a data block that can be interpreted as a container of other data sources, in particular file sources. This means that a <a href="#dfn-file-source">file source</a> may reside within the data blocks represented by another <a href="#dfn-data-source">data source</a>, as e.g. in the case of a file contained inside another zipped file. In such cases, the container source of a file source may be specified by the <a href="#dris:containerSource"><code>dris:containerSource</code></a> property. In such cases, the respective <a href="#dfn-path">path</a> is the location of the file inside the container source. In this case, if <a href="#dfn-path">path</a> equals <code>*</code> the source represents the set of data blocks corresponding to all files in the container source.</p>
		
				<div class="marker" id="container-source-example-1">
					<pre class="example" title="An HTTP source representing a password protected zipped file, and two file sources representing specific files within that zipped file."><code>
<#RemoteZipFile>  
   a dris:HTTPSource ;
   dris:uri "http://www.example.com/data/all.zip" ;
   dris:password "A$2@3KZa" .

<#CompaniesSource>  
   a dris:FileSource ;
   dris:containerSource <#RemoteZipFile> ;
   dris:path "content/companies.csv" .
   
<#PersonsSource>  
   a dris:FileSource ;
   dris:containerSource <#RemoteZipFile> ;
   dris:path "content/persons.csv" .
					</code></pre>
				</div>
			
				<p>In the above example, the container source is used twice to provide access to two of the contained files. If the container is going to be used only once, to access a single file within it, the respective data block can be written as a single data source using the <a href="#dris:inContainerPath"><code>dris:inContainerPath</code></a> property. As before, <code>dris:inContainerPath</code> may equal <code>*</code>. Formally, <code>?x ?p1 ?y1 . ... . ?x ?pn ?yn . ?x dris:inContainerPath ?v</code>, where <code>p1</code>, ..., <code>pn</code> are predicates other than <code>dris:containerSource</code> is a shortcut for <code>?z ?p1 ?y1 . ... . ?z ?pn ?yn . ?w a dris:FileSource . ?w dris:containerSource ?z . ?w dris:path ?v</code>.</p>
			
				<div class="marker" id="container-source-example-2">
					<pre class="example" title="An HTTP source representing a specific file within the password protected zipped file the raw data of the HTTP source."><code>
<#CompaniesSource>  
   a dris:HTTPSource ;
   dris:uri "http://www.example.com/data/all.zip" ;
   dris:password "A$2@3KZa" .
   dris:inContainerPath "content/companies.csv" .
					</code></pre>
				</div>			
			
				<p>Container sources may be nested.</p>
<!--			
				<div class="marker">
					<pre class="example" title="A file source contained in a packed file source which in turn is a compressed file source."><code>
<#TarGzFile>  
   a dris:FileSource ;
   dris:uri "d:/data/all.tar.gz" .
</code><code>
<#TarFile>  
   a dris:FileSource ;
   dris:containerSource <#TarGzFile> ;
   dris:path "all.tar" .
</code><code>
<#CSVFileSource>  
   a dris:FileSource ;
   dris:containerSource <#TarFile> ;
   dris:path "content/input.csv" .
					</code></pre>
				</div>			
-->		
				<p>D2RML defines a concrete file source instance, <a href="#dris:CurrentD2RMLDocument"><code>dris:CurrentD2RMLDocument</code></a>, which represents the D2RML document currently being processed by the <a href="#dfn-d2rml-processor">D2RML processor</a>.</p>

			</section>
			
		</section>
		
		<section id="service-sources">
			<h3>Service Sources</h3>

			<p>A <dfn id="dfn-service-source">service source</dfn> is an information source that represents a data repository, from which <a href="#dfn-data-block">data blocks</a> are eventually obtained by issuing a specific request to the service source, usually in the form of a query in a language that the service source understands. Usually, the data blocks obtained from a service source have a specific format that depends on the type of the source. A specific service source is a subclass of <a href="#dris:ServiceSource"><code>dris:ServiceSource</code></a> which is the abstract class of all service sources. The descriptions of a service source contains the necessary information for establishing the connection to the service source, but not the queries by which the data blocks are obtained.

			<p>Currently supported service sources are <a href="#dfn-sparql-endpoint">SPARQL endpoints</a>, which represent SPARQL endpoints answering SPARQL queries, and <a href="#dfn-rdbms">RDBMS</a>s, which represent relational database management systems answering SQL queries.</p>
		
			<section id="sec-sparql-endpoints">
				<h4>SPARQL Endpoints</h4>
				
				<p>A <dfn id="dfn-sparql-endpoint">SPARQL endpoint</dfn> is an instance of <a href="#dris:SPARQLEndpoint"><code>dris:SPARQLEndpoint</code></a> and is specified only by the URI the endpoints listens to through the <a href="#dris:uri"><code>dris:uri</code></a> property.</p>
			
				<div class="marker">
					<pre class="example" title="The Wikidata SPARQL endpoint."><code>
<#WikidataEndpoint>
   a dris:SPARQLEndpoint ;
   dris:uri "https://query.wikidata.org/bigdata/namespace/wdq/sparql" .
					</code></pre>
				</div>		
	
			</section>
			
			<section id="sec-rdbms">
				<h4>Relational Databases</h4>
				
				<p>A <dfn id="dfn-rdbms">RDBMS</dfn> is an instance of <a href="#dris:RDBMS"><code>dris:RDBMS</code></a> and is specified by its type, property and its location. The <dfn id="dfn-rdbms-type">RDBMS type</dfn> determines the RDBMS system and may influence access to it. It is specified by the <a href="#dris:rdbmsType"><code>dris:rdbmsType</code></a> property, it is a URI, and the accepted values are listed in the <a href="#rdbms-types">RDBMS types</a> section. The location may be either a URI, specified by a <a href="#dris:uri"><code>dris:uri</code></a> property, or a <a href="#dfn-path">path</a>, if the RDBMS is a local file (e.g. a Microsoft Access database), through a <a href="#dris:path"><code>dris:path</code></a> property. Usually, the specification of an RDBMS will include also a <dfn id="dfn-database-name">database name</dfn>, specified through the <a href="#dris:databaseName"><code>dris:databaseName</code></a> property, an the necessary credentials provided through the <a href="#dris:credentials"><code>dris:credentials</code></a> property.</p>
			
				<div class="marker">
					<pre class="example" title="A MySQL RDBMS information source."><code>
<#MySQLDatabase>
   a dris:RDBMS ;
   dris:rdbmsType dris:MySQL
   dris:uri "http://data.org/db-access" ;
   dris:databaseName "companies" ;
   dris:credentials [
      a dris:PasswordCredentials ;
      dris:username "root" ;
      dris:password "r@@Tx#" 
   ] .
					</code></pre>
				</div>	
			
				<div class="marker">
					<pre class="example" title="A Microsoft Access RDBMS information source."><code>
<#MSAccessDatabase>
   a dris:RDBMS ;
   dris:rdbmsType dris:MicrosoftAccess
   dris:path "c:/data/database.mdb" ;
					</code></pre>
				</div>		

			</section>
		</section>

		<section id="string-source">
			<h3>String Sources</h3>
		
			<p>An information source may also be a <dfn id="dfn-string-source">string source</dfn>, which represents a single data block that is a directly provided user-defined string. It is an instance of <a href="#dris:StringSource"><code>dris:StringSource</code></a>, and the string is provided through the <a href="#dris:string"><code>dris:string</code></a> property, which typically will make use of a <a href="dfn-parameter">parameter</a>.</p>
			
			<div class="marker">
				<pre class="example" title="A simple string source."><code>
<#StringSource>
   a dris:StringSource ;
   dris:string "name;surname\nJohn;Smith" .
				</code></pre>
			</div>		
			
			<div class="marker">
				<pre class="example" title="String source whose content is specified through a parameter."><code>
<#StringSource>
   a dris:StringSource ;
   dris:string "{@@VALUE@@}" ;
   dr:parameter [
      a dr:ExternalParameter ;
      dr:name "VALUE" 
   ] .
				</code></pre>
			</div>
<!--		<p>An information source may be parametric. A parameter of an information source may be either an externally provided constant value to the D2RML Processor, of a <a href="#dris:RequestIterator"><code>dris:RequestIterator</code></a></p>. A request iterator is used to when several requests should be sent to the information source in order to obtained the full set of data, e.g. when the source returns the results in pages. A request iterator may be a <a href="#dris:SimpleCountRequestIterator"><code>dris:SimpleCountRequestIterator</code></a>, a <a href="#dris:SimpleKeyRequestIterator"><code>dris:SimpleKeyRequestIterator</code></a> or a <a href="#dris:EnumerateRequestIterator"><code>dris:EnumerateRequestIterator</code></a> -->
		
		</section>
		
		<section id="sec-transient-rdf-dataset">
			<h3>Transient RDF Datasets</h3>
			
			<p>Apart from the above, an information source may be a <dfn id="transient-rdf-dataset">transient RDF dataset</dfn>, which represents an initially empty RDF dataset which will be created by the <a href="#dfn-d2rml-processor">D2RML processor</a> upon processing the underlying D2RML document.</p>
			
			<p>Typically a transient RDF dataset will serve as the <a href="#dfn-logical-output">logical output</a> for one or more <a href="#dfn-triples-map">triples maps</a>, <a href="#dfn-rdf-map">rdf maps</a> or <a href="#dfn-triples-dataset">triples datasets</a>, i.e. elements that cause the <a href="#dfn-d2rml-processor">D2RML processor</a> to produce RDF triples, and used as an <a href="#dfn-information-source">information source</a> by other triples or plain text generating elements. A transient RDF dataset cannot be parametric.</p>
			
			<div class="marker">
				<pre class="example" title="A transient RDF dataset source."><code>
<#TempDataset>
   a dris:TransientRDFDataset ;
				</code></pre>
			</div>		
			
		</section>

<!-- TODO
		<section id="rdfdataset-source">
			<h3>External RDF dataset</h3>
		</section>
-->		
	</section>

	<section id="sec-logical-inputs">
		<h2>Logical Inputs</h2>
		
		<p>A <dfn id="dfn-logical-input">logical input</dfn> is a specific, useful interpretation of the <a href="dfn-data-block">data blocks</a> obtained from an <a href="#dfn-information-source">information source</a>. The specification of the logical input must provide all necessary information to obtain such interpretation. <a href="#dr:LogicalInput"><code>dr:LogicalInput</code></a> is the abstract class of all logical inputs. A <a href="#dr:LogicalInput"><code>dr:LogicalInput</code></a> instance <em class="rfc2119">MUST</em> have a <a href="#dr:source"><code>dr:source</code></a> property, which determines the information source from which the data blocks are obtained.</p>
		
		<figure id="logical-inputs"><img src="logical-inputs.png" alt="Logical Inputs">
			<figcaption><span class="fig-title">Logical Input classes.</span></figcaption> 
		</figure>

		
		<p>A <a href="#dfn-logical-input">logical input</a> can be either a <a href="#dfn-logical-graph">logical graph</a>, a <a href="#dfn-logical-table">logical table</a> of a logical array <a href="#dfn-logical-array">logical array</a>.</p>
		
		<p><a href="#dfn-logical-table">Logical tables</a> and <a href="#dfn-logical-array">logical arrays</a> share the common property that they are logical inputs that consist of a series of objects of identical structure that can be iterated over. These objects are the <dfn id="dfn-logical-row">logical rows</dfn> of the logical input. An iterator iterating on the logical rows of a logical table or logical array typically consumes all rows starting from the first row (with index 0) and continuing until the last row. This can be changed by specifying an <a href="#dfn-offset">offset</a> and a <a href="#dfn-limit">limit</a> using the <a href="#dr:offset"><code>dr:offset</code></a> and <a href="#dr:limit"><code>dr:limit</code></a> properties respectively. The <dfn id="dfn-offset">offset</dfn> is the index of the logical row from which the iterator should start consuming rows, and <dfn id="dfn-limit">limit</dfn> is the number of subsequent logical rows that will be consumed by the iterator. If no offset is specified, it is assumed to be 0, whereas if no limit is specified the iterator will consume all logical rows starting from to offset index until the last logical row.</p>
		
		<p>The logical rows of a logical table or logical array are divided in <dfn id="dfn-logical-column">logical columns</dfn>, which represent subparts of the logical rows, and they are accessible through a <dfn id="dfn-column-name">column name</dfn>. 
		
<!--		<p>The abstract class of iterable logical inputs is <a href="#dr:IterableLogicalInput"><code>dr:IterableLogicalInput</code></a>. Iterable logical inputs</dfn> are divided in <a href="#dfn-logical-table">logical tables</a> and <a href="#dfn-logical-array">logical arrays</a>.</p>-->
		
		<section id="logical-graphs">
			<h3>Logical Graphs</h3>
		
			<p>A <dfn id="dfn-logical-graph">logical graph</dfn> represents an interpretation of a data block provided from an information source as an RDF graph [[RDF11-CONCEPTS]]. It is an instance of <a href="#dr:LogicalGraph"><code>dr:LogicalGraph</code></a>. The following example shows how a TRIG file can be interpreted as a logical graph.</p>
			
			<div class="marker" id="ex-logical-graph-1">
				<pre class="example" title="A logical graph obtained from a TRIG file."><code>
<#TRIGFile>
   a dris:FileSource ;
   dris:path "c:/data/dataset.trig" .

<#LogicalGraph>
   a dr:LogicalGraph ;
   dr:source <#TRIGFile> .
				</code></pre>
			</div>
			
			<p>In the above example the RDF graph represented by the logical graph is the default graph of the underlying TRIG file. If another named graph is desired, it can be specified by the <a href="#dr:namedGraph"><code>dr:namedGraph</code></a> property.</p>

			<div class="marker" id="ex-logical-graph-2">
				<pre class="example" title="A logical graph obtained as a named graph from a TRIG file."><code>
<#TRIGFile>
   a dris:FileSource ;
   dris:path "c:/data/dataset.trig" .

<#LogicalGraph>
   a dr:LogicalGraph ;
   dr:source <#TRIGFile> ;
   dr:namedGraph &lt;http://example.org/companies/> .
				</code></pre>
			</div>
			
			This use of a logical graph is particularly useful for accessing data triples provided in a named graph of the current D2RML document by using as source <a href="#dris:CurrentD2RMLDocument"><code>dris:CurrentD2RMLDocument</code></a>.
			
			<div class="marker" id="ex-logical-graph-3">
				<pre class="example" title="A logical graph obtained from the current D2RML Document."><code>
<#LogicalGraph>  
   dr:logicalGraph [ 
      dr:source dris:CurrentD2RMLDocument ;
      dr:namedGraph <#Data> ;
   ] .	
	
<#Data> {
   &lt;http://example.com/comanies/C145>
      a   dcterms:Agent ;
      dcterms:title "International Company"@en  ;
      foaf:homepage &lt;https://www.international-company.net/> .
}
				</code></pre>
			</div>

			
		</section>

		<section id="logical-tables">			
			<h3>Logical Tables</h3>
			
			<p>A <dfn id="dfn-logical-table">logical table</dfn> is one or more data blocks interpreted as a table, consisting of rows and columns, where the tabular form is inherent in the data block structure. This means that typically no additional information is needed to obtain the logical rows from the data block; the rows of the table correspond exactly to the <a href="#dfn-logical-row">logical rows</a> of the <a href="#dfn-logical-input">logical input</a>.</p>

			<p>Logical tables can be obtained from SQL query results, SPARQL queries results, CSV file contents, etc. A concrete logical table is a subclass of <a href="#dr:LogicalTable"><code>dr:LogicalTable</code></a>. The specification of a logical table must contain any necessary information for translating the data block returned from the information source to a table, and possibly additional information to the information source for providing a concrete data block (e.g. a query).</p>
			
			<p>The access to the data in a logical table is done by <a href="#dfn-column-name">column names</a>. The set of column names for each logical table is fixed and determined at the time the logical table is constructed.</p>

<!--			<p>Currently supported logical tables are <a href="#rr:BaseTableOrView"><code>rr:BaseTableOrView</code></a>, <a href="#rr:R2RML"><code>rr:R2RMLView</code></a>, <a href="#dr:CSVTable"><code>dr:CSVTable</code></a>, <a href="#dr:Spreadsheet"><code>dr:Spreadsheet</code></a>, <a href="#dr:SPARQLQueryResult"><code>dr:SPARQLQueryResult</code></a> and <a href="#dr:SPARQLQueryResult"><code>dr:SetTable</code></a>.</p> -->
			
			<p>Currently supported logical tables are <a href="#dfn-sql-base-table-or-view">SQL base table or views</a>, <a href="#dfn-r2rml-view">R2RML views</a>, <a href="#dfn-csv-table">CSV tables</a>, <a href="dfn-spreadsheet">spreadsheets</a>, <a href="#dfn-sparql-query-result">SPARQL query results</a> and <a href="#dfn-set-table">set tables</a>.</p>
			
			<section id="sec-sql-base-table-or-view">
				<h4>SQL Base Tables or Views and R2RML Views</h4>
			
				<p>A <dfn id="dfn-sql-base-table-or-view">SQL base table or view</dfn> is a <a href="#dfn-logical-table">logical table</a> containing SQL data from a base table or view of an <a href="#dfn-rdbms">RDBMS</a> information source.</p>
				
				<p>An <dfn id="dfn-r2rml-view">R2RML view</dfn> is a logical table whose contents are the result of executing a SQL query against an <a href="#dfn-rdbms">RDBMS</a> information source. It is an instance of <a href="#rr:RMLView"><code>rr:RMLView</code></a> [[R2RML]].</p> 
			
			
				<p>Note that, in contrast to [[R2RML]], in a D2RML document, an instance of <a href="#rr:BaseTableOrView"><code>rr:BaseTableOrView</code></a> and <a href="#rr:RMLView"><code>rr:RMLView</code></a> <em class="rfc2119">MUST</em> include also a <a href="#dr:source"><code>dr:source</code></a> property to specify the relevant <a href="#dfn-rdbms">RDBMS</a> information source.</p>
			
				<p>The <a href="#dfn-column-name">column names</a> of a <a href="#dfn-sql-base-table-or-view">SQL base table or view</a> or <a href="#dfn-r2rml-view">R2RML view</a> are the column names of the underlying relational table or view.</p>
			
			</section>
			
			<section id="sec-csv-tables">
				<h4>CSV Tables</h4>
				
				<p>A <dfn id="dfn-csv-table">CSV table</dfn> represents a <a href="#dfn-logical-table">logical table</a> obtained from data CSV-like formatted data blocks. It is an instance of <a href="#dr:CSVTable"><code>dr:CSVTable</code></a>. The formatting details of the data block that are needed to interpret it as a CSV table are specified by the  <a href="#dr:commentMarker"><code>dr:commentMarker</code></a>, <a href="#dr:delimiter"><code>dr:delimiter</code></a>, <a href="#dr:escapeCharacter"><code>dr:escapeCharacter</code></a> (default value <code>\</code>), <a href="#dr:quoteCharacter"><code>dris:quoteCharacter</code></a>, and <a href="#dr:recordSeparator"><code>dris:recordSeparator</code></a> (default value <code>\n</code>). A CSV table may have a <dfn id="dfn-header-record">header record</dfn>, which does not provide data, but names for the columns of the data in the CSV table. Whether a CSV table contains a header record can be specified by the <a href="#dr:headerRecord"><code>dr:headerRecord</code></a> property.</p>
			
				<p>The <a href="#dfn-column-name">column names</a> of a <a href="#dfn-csv-table">CSV table</a> are the column names specified in the <a href="#dfn-header-record">header record</a>, if any. In addition, each column is assigned also the name <code>##N</code>, where <code>N</code> ranges from 1 to the overall number of columns.</p>

			
				<div class="marker">
					<pre class="example" title="A logical table obtained from CSV data."><code>
<#CompaniesSource> 	  
   a dris:FileSource ;
   dris:path "d:/data/companies.csv" .

<#CompaniesMapping>  
   rr:logicalTable [ 
      a dr:CSVTable ;
      dr:source <#CompaniesSource> ;
      dr:delimiter "\t" ;
      dr:headerRecord true ;
      dr:quoteCharacter "\""
   ] ;   
   ...
					</code></pre>
				</div>		
			</section>
			
			<section id="sec-spreadsheets">
				<h4>Spreadsheets</h4>
				
				<p>A <dfn id="dfn-spreadsheet">spreadsheet</dfn> represents a <a href="#dfn-logical-table">logical table</a> obtained from a specific sheet of a spreadsheet data block. It is an instance of <a href="#dr:Spreadsheet"><code>dr:Spreadsheet</code></a>. The name of the sheet is specified by the <a href="#dr:sheetName"><code>dr:sheetName</code></a> property. The type of the spreadsheet (e.g. xls) should be obtained from the file format of the underlying <a href="#dfn-data-source">data source</a>.</p>
			
				<p>The <a href="#dfn-column-name">column names</a> of a <a href="#dfn-spreadsheet">spreadsheet</a> are the column names of the underlying spreadsheet, typically A, B, C, etc.</p>

			
				<div class="marker">
					<pre class="example" title="A logical table obtained from an Excel spreadsheet."><code>
<#CompaniesSource> 	  
   a dris:FileSource ;
   dris:path "d:/data/companies.xlsx" .

<#CompaniesMapping>  
   rr:logicalTable [ 
      a dr:Spreadsheet ;   
      dr:source <#CompaniesSource> ;
      dr:sheetName "Sheet1" ;
      dr:offset 1 
   ] ;   
   ...
					</code></pre>
				</div>		

			</section>
			
			<section id="sec-sparql-query-result">
				<h4>SPARQL Query Results</h4>
			
				<p>A <dfn id="dfn-sparql-query-result">SPARQL query result</dfn> represents a <a href="#dfn-logical-table">logical table</a> obtained from executing a SELECT SPARQL query against a <a href="#dfn-sparql-endpoint">SPARQL endpoint</a> information source. It is an instance of <a href="#dr:SPARQLQueryResult"><code>dr:SPARQLQueryResult</code></a>. The SPARQL SELECT query <em class="rfc2119">MUST</em> by specified by the <a href="#dr:sparqlSelectQuery"><code>dr:sparqlSelectQuery</code></a> property. The version of SPARQL language can be specified by the <a href="#dr:sparqlVersion"><code>dr:sparqlVersion</code></a> property. If not included in the query, the set of graphs that will be used as the default graphs, and the set of named graphs available to the query can be specified by the <a href="#dr:defaultGraph"><code>dr:defaultGraph</code></a> and <a href="#dr:namedGraph"><code>dr:namedGraph</code></a> properties respectively, according to the [[SPARQL11-PROTOCOL]].</p>
			
				<p>The <a href="#dfn-column-name">column names</a> of a <a href="#dfn-sparql-query-result">SPARQL query result</a> are the names of the variables in the underlying query result list.</p>
			
				<div class="marker">
					<pre class="example" title="A logical table obtained from executing a SPARQL query against a SPARQL Endpoint."><code>
<#WikidataEndpoint>
   a is:SPARQLEndpoint ;
   is:uri "https://query.wikidata.org/bigdata/namespace/wdq/sparql" .

<#Mapping>
   rr:logicalTable [ 
      a dr:SPARQLQueryResult ;
      dr:source <#WikidataEndpoint> ;
      dr:sparqlSelectQuery "PREFIX wd: <http://www.wikidata.org/entity/> PREFIX wdt: <http://www.wikidata.org/prop/direct/> SELECT ?entity WHERE { ?entity wdt:P31 wd:Q11424 }"   
   ] ;
   ...
					</code></pre>
				</div>
				
				<p>The source of a SPARQL query results element, apart from a <a href="#dfn-sparql-endpoint">SPARQL endpoint</a> can be also a <a href="#dfn-data-source">data source</a> providing RDF data.</p>
			
				<div class="marker">
					<pre class="example" title="A logical table obtained from executing a SPARQL query against a RDF data file."><code>
<#RDFDataSource>
   a dris:HTTPSource ;
   dris:uri "http://www.example.org/data/companies.ttl" .

<#Mapping>
   rr:logicalTable [ 
      a dr:SPARQLQueryResult ;
      dr:source <#RDFDataSource> ;
      dr:sparqlSelectQuery "PREFIX ex: <http://www.example.org/> SELECT ?id WHERE { ?id a ex:Company }" ; 
   ] ;
   ...
					</code></pre>				
				</div>		
			
			</section>
			
		</section>
		
		<section id="logical-arrays">			
			<h3>Logical Arrays</h3>
			
			<p>A <dfn id="dfn-logical-array">logical array</dfn> represents one or more textual <a href="#dfn-data-block">data blocks</a> interpreted as an array of one or more objects obtained by applying an <a href="#dfn-iterator">iterator</a> on the data block.</p>
			
			<p>An <dfn id="dfn-iterator">iterator</dfn> is a data selection expression, in some standard language that makes sense for the file format of the underlying data blocks. The iterator is specified by the <a href="#dr:iterator"><code>dr:iterator</code></a> property, and its language, the <dfn id="dfn-iterator-formulation">iterator formulation</dfn>, by the <a href="#dr:iteratorFormulation"><code>dr:iteratorFormulation</code></a> property. The result of applying the iterator on the data block is a sequence of possibly complex objects, which represent the <a href="#dfn-logical-row">logical rows</a> of the resulting logical array. Unlike in the case of <a href="#dfn-logical-table">logical tables</a>, a logical array does not consist of a predetermined number of columns with specific column names. Instead, the <a href="#dfn-logical-column">logical columns</a> in a logical array are virtual, in the sense that they are obtained again by applying another data selection expression on the object of each logical row. The language of this expression,  the <dfn id="dfn-column-formulation">column formulation</dfn>, is specified by the <a href="#dr:columnFormulation"><code>dr:columnFormulation</code></a> property.</p>
			
			<!-- 
			<p>If no <a href="#dr:iterator"><code>dr:iterator</code></a> is specified, the data block is interpreted as a sequence of lines, where are the logical rows, from which the the logical array will be obtained.</p>
			-->
			
			<p>Currently supported logical arrays are <a href="#dfn-json-array">JSON arrays</a>, <a href="#dfn-xml-array">XML arrays</a> and <a href="#dfn-regex-array">regular expression arrays</a>.</p>
			
			<section id="sec-json-arrays">
				<h4>JSON Arrays</h4>
				
				<p>A <dfn id="dfn-json-array">JSON array</dfn> is a sequence of JSON objects. It is an instance of <a href="#dr:JSONItemArray"><code>dr:JSONItemArray</code></a>. The <a href="#dr:iteratorFormulation"><code>dr:iteratorFormulation</code></a> must be either <a href="#dris:JSONPath"><code>dris:JSONPath</code></a> or <a href="#dris:JSONElement"><code>dris:JSONElement</code></a> and <a href="#dr:columnFormulation"><code>dr:columnFormulation</code></a> will typically be <a href="#dris:JSONPath"><code>dris:JSONPath</code></a>, which is the default value if no column formulation is specified.</p>

				<p>Depending on the iterator formulation, the <a href="#dr:iterator"><code>dr:iterator</code></a> must be either a JSONPath expression whose evaluation returns the desired array of JSON objects that will make up the <a href="#dfn-logical-row">logical rows</a>, or a JSON field name whose value is the desired array of JSON objects. If the data block provided by the information source is a JSON document that has is an array, and it is desired that iteration is done over the elements of that array with iterator formulation <a href="#dris:JSONElement"><code>dris:JSONElement</code></a>, no iterator should be specified. The <a href="#dfn-column-name">column names</a> for a JSON array are also JSONPath expressions that make sense in the context of the logical row objects.</p>
			
				<div class="marker">
					<pre class="example" title="A logical array obtained from JSON formatted data."><code>
<#DataSource>
   a dris:HTTPSource ;
   dris:uri "http://www.example.org/data/data.json" .

<#Mapping>
   rr:logicalArray [ 
      a dr:JSONItemArray ;
      dr:source <#DataSource> ;
      dr:iterator "$.companies" ; 
      dr:iteratorLanguage dris:JSONPath ; 
      dr:columnLanguage dris:JSONPath 
   ] ;
	   ...
					</code></pre>				
				</div>		
			</section>
			
			<section id="sec-xml-arrays">
				<h4>XML Arrays</h4>
				
				<p>An <dfn id="dfn-xml-array">XML array</dfn> is a sequence of XML nodes. It is an instance of <a href="#dr:XMLItemArray"><code>dr:XMLItemArray</code></a>.  The <a href="#dr:iteratorFormulation"><code>dr:iteratorFormulation</code></a> must be either <a href="#dris:XPath"><code>dris:XPath</code></a> or <a href="#dris:XMLElement"><code>dris:XMLElement</code></a>, and the <a href="#dr:columnFormulation"><code>dr:columnFormulation</code></a> will typically  be <a href="#dris:XPath"><code>dris:XPath</code></a>, which is the default value if no column formulation is specified.</p>
			
				<p>If <a href="#dr:iteratorFormulation"><code>dr:iteratorFormulation</code></a> is <a href="#dris:XPath"><code>dris:XPath</code></a>, the <a href="#dr:iterator"><code>dr:iterator</code></a> must be an XPath expression whose evaluation  returns the desired array of XML nodes that will make up the <a href="#dfn-logical-row">logical rows</a>. If it is <a href="#dris:XMLElement"><code>dris:XMLElement</code></a>, the <a href="#dr:iterator"><code>dr:iterator</code></a> must be a single XML element name, and the resulting of XML nodes making up the <a href="#dfn-logical-row">logical rows</a> will be exactly the XML elements of the document having that name. The <a href="#dfn-column-name">column names</a> for an XML array are XPath expressions that make sense in the context of the logical row objects.</p>
			
				<div class="marker">
					<pre class="example" title="A logical array obtained from XML formatted data."><code>
<#DataSource>
   a dris:HTTPSource ;
   dris:uri "http://www.example.org/data/data.xml" .

<#Mapping>
   rr:logicalArray [ 
      a dr:XMLItemArray ;
      dr:source <#DataSource> ;
      dr:iterator "//companies" ; 
      dr:iteratorLanguage dris:XPath ; 
      dr:columnLanguage dris:XPath  
   ] ;
   ...
					</code></pre>				
				</div>		

			</section>
			
			<section id="sec-regex-arrays">
				<h4>Regular Expression Arrays</h4>
				
				<p>A <dfn id="dfn-regex-array">regular expression array</dfn> is a sequence of lists of string objects. It is an instance of <a href="#dr:RegExItemArray"><code>dr:RegExItemArray</code></a>. The <a href="#dr:iteratorFormulation"><code>dr:iteratorFormulation</code></a> and <a href="#dr:columnFormulation"><code>dr:columnFormulation</code></a> <em class="rfc2119">MUST</em> be a regex syntax supported by the <a href="#dfn-d2rml-processor">D2RML processor</dfn> such as <a href="#dris:JavaRegEx"><code>dris:JavaRegEx</code></a>. The value of <a href="#dr:iterator"><code>dr:iterator</code></a> must be a regular expression involving one or more capturing groups. Each match of the expression against the underlying  <a href="#dfn-data-block">data block</a> will give rise to a <a href="#dfn-logical-row">logical row</a>. The logical rows consist then of so many columns as are the iterator capturing groups, which are assigned the names <code>##N</code>, where <code>N</code> ranges from 1 to the overall number of capturing groups. These are the <a href="#dfn-column-name">column names</a> that can be used to access the data in the respective <a href="#dfn-logical-column">logical columns</a>.</p>

				<div class="marker">
					<pre class="example" title="A logical array obtained from textual data."><code>
<#DataSource>
   a dris:HTTPSource ;
   dris:uri "http://www.example.org/data/data.html" .

<#Mapping>
   rr:logicalArray [ 
      a dr:RegExItemArray ;
      dr:source <#DataSource> ;
      dr:iterator "&lt;table id='companies'>(.*?)&lt;table>" ; 
      dr:iteratorLanguage dris:JavaRegEx ; 
      dr:columnLanguage dris:JavaRegEx  
   ] ;
   ...
					</code></pre>				
				</div>		
			</section>
		
		</section>

		<section id="set-tables">
			<h3>Set Tables</h3>
		</section>
	</section>	

	<section id="sec-logical-datasets">
		<h2>Logical Datasets</h2>
		
		<p>A <dfn id="dfn-logical-dataset">logical dataset</dfn> represents a specification for obtaining and generating data from a <a href="#dfn-logical-input">logical input</a>.</p>
		
		<p>The abstract class of all logical datasets is <a href="#dr:LogicalDataset"><code>dr:LogicalDataset</code></a>. A logical dataset can be either a <a href="#dfn-mapping-dataset">mapping dataset</a> or a <a href="#dfn-triples-dataset">triples dataset</a>. 
		
		<figure id="fig-logical-datasets"><img src="logical-datasets-3.png" alt="Logical Datasets and Maps">
			<figcaption><span class="fig-title">Logical Dataset and Value Map related classes.</span></figcaption> 
		</figure>


		<section id="sec-mapping-datasets">
			<h3>Mapping Datasets</h3>
			
			<p>A <dfn id="dfn-mapping-dataset">mapping dataset</dfn> represents the contents of a <a href="#dfn-logical-array">logical array</a> or <a href="#dfn-logical-table">logical table</a> together with some instructions for generating new data from the contents of a logical array or logical table. The logical array or logical table are specified through the <a href="#dr:logicalArray"><code>dr:logicalArray</code></a> or <a href="#dr:logicalTable"><code>dr:logicalTable</code></a> property respectively.</p><p>
			
			<p>The content generation instructions of a mapping dataset can be a <a href="#dfn-triples-map">triples map</a>, an <a href="#dfn-rdf-map">RDF map</a> or a <a href="#dfn-text-lines-map">text lines map</a>. The first two, which are specified by a <a href="#dr:triplesMap"><code>dr:triplesMap</code></a> and <a href="#dr:rdfMap"><code>dr:rdfMap</code></a> property, respectively, generate RDF datasets, while the latter, which is specified by a <a href="#dr:textLinesMap"><code>dr:textLinesMap</code></a> property generates lines of plain text. A mapping dataset <em class="rfc2119">MAY</em> have zero or more <a href="#dfn-triples-map">triples maps</a>, <a href="#dfn-rdf-map">RDF maps</a> and <a href="#dfn-text-lines-map">text lines maps</a>, but <em class="rfc2119">MUST</em> have at least one of them.</p>
			
			<p>A <a href="#dfn-triples-map">triples map</a>, an <a href="#dfn-rdf-map">RDF map</a> or a <a href="#dfn-text-lines-map">text lines map</a> contained within a mapping dataset, typically generate data be applying the content generating instructions on the respective <a href="#dfn-logical-input">logical input</a>. However they can operate also on <a href="#dfn-logical-extension">logical extensions</a> of the logical inputs. <a href="#dfn-defined-column">defined column</a> and <a href="#dfn-transformation">transformation</a> based logical extension can be provided by the <a href="#dr:definedColumn"><code>dr:definedColumn</code></a> or <a href="#dr:definedColumns"><code>dr:definedColumns</code></a> properties, and the <a href="#dr:transformation"><code>dr:transformation</code></a> or <a href="#dr:transformations"><code>dr:transformations</code></a> properties, respectively.</p>
<!--
		
		<section id="sec-mapping-datasets">
			<h3>Mapping Datasets</h3>
			
			A <dfn id="dfn-mapping-dataset">logical iterable dataset</dfn> represents the contents of a <a href="#dfn-logical-array">logical array</a> or <a href="#dfn-logical-table">logical table</a>. It is an instance of <a href="#dr:LogicalIterableDataset"><code>dr:LogicalIterableDataset</code></a> and the logical array or logical table as specified through the <a href="#dr:logicalArray"><code>dr:logicalArray</code></a> or <a href="#dr:logicalTable"><code>dr:logicalTable</code></a> property respectively.</p>
			
						<div class="marker" id="ex-logical-iterable-dataset">
				<pre class="example" title="A logical iterable dataset obtained from an HTTP API serving JSON data."><code>
<#DataSource>
   a dris:HTTPSource ;
   dris:uri "https://example.org/api/data?id=1456" .

<#LogicalDataset>
   a dr:LogicalIterableDataset
   dr:logicalArray [ 
      a dr:JSONItemArray ;
      dr:source <#DataSource> ;
      dr:iterator "$";
   ] . 
				</code></pre>
			</div>
			
		</section>
-->		
		</section>		

		<section id="sec-triples-datasets">
			<h3>Triples Datasets</h3>
			
			<p>A <dfn id="dfn-triples-dataset">triples dataset</dfn> is a set of triples represented by a <a href="#dfn-logical-graph">logical graph</a>. A triples dataset <em class="rfc2119">MUST</em> contain exactly one logical graph, provided by the <a href="#dr:logicalGraph"><code>dr:logicalGraph</code></a> property. The triples in the logical graph will be included as they are in the RDF dataset produced by the D2RML processor (after possible adding them to the specified named graphs).</p>
			
			The output of the below D2RML document will be just the triples contained in <code>c:/data/dataset.ttl</code>.
			
			<div class="marker" id="ex-triples-dataset">
				<pre class="example" title="A triples dataset obtained from a TTL file."><code>
<#TRIGFile>
   a dris:FileSource ;
   dris:path "c:/data/dataset.ttl" .

<#LogicalDataset> 
   a dr:TriplesDataset
   dr:logicalGraph [
      dr:source <#TRIGFile>
   ] .
				</code></pre>
			</div>
			
		</section>		

	</section>
	
	<section id="sec-logical-extensions">
		<h3>Logical Extensions</h3>
	
		<p>A <dfn id="dfn-logical-extension">logical extension</dfn> is a specification for extending each <a href="#dfn-logical-row">logical row</a> of a <a href="#dfn-logical-array">logical array</a> or <a href="#dfn-logical-table">logical table</a> by additional <a href="#dfn-logical-row">logical columns</a>. A local extension is an instance of <a href="#dr:LogicalExtension"><code>dr:LogicalExtension</code></a> which is the abstract class of logical extensions. The logical columns added by a logical extension are identified by the value of the <a href="#dr:name"><code>dr:name</code></a> property that each instance of a logical extension must have.</p>
		
		<p>Since logical extension, extends a logical row, and the logical rows are obtained by iterating on a logical table or logical array, the values of the logical row (before the extension) can act as parameter values for the computation of the new logical columns for the particular logical row that the logical extension will essentially provide. In case parameters are involved, the parameter bindings are provided by the <a href="#dr:parameterBinding"><code>dr:parameterBinding</code></a> property, whose value is a <a href="#dfn-parameter-binding">parameter binding</a>.</p>
		
		<figure id="fig-logical-extensions"><img src="logical-extensions.png" alt="Logical extensions">
			<figcaption><span class="fig-title">Logical extension classes.</span></figcaption> 
		</figure>
		
		<p>Logical extensions may be either <a href="#dfn-defined-column">defined columns</a> or <a href="#dfn-transformation">transformations</a>. Defined columns and transformations can be applied incrementally as a logical table or logical array is extended with additional columns.</p>
		
<!--		That logical columns added be a logical extension are the result of applying a <a href="#dfn-function">function</a> or a <a href="#dfn-transformation">transformation</a> on the logical columns of the existing logical table or array. Functions and transformations  can be applied recursively as the logical table or array is extended with additional columns. </p> -->

			
		<section id="sec-defined-columns">
			<h3>Defined Columns</h3>

			<p>A <dfn id="dfn-defined-column">defined column</dfn> represents a set of one or more logical columns added to the current logical array or table for by applying a <a href="#dfn-function">function</a> on a <a href="#dfn-value-map">value map</a> defined over the existing logical columns of the logical array or table. A defined column is an instance of <a href="#dr:DefinedColumn"><code>dr:DefinedColumn</code></a>. <!-- and must be given a <a href="#dfn-column-name"> column name</a> using the <a href="#dr:name"><code>dr:name</code></a> property. -->The <a href="#dfn-logical-cell-content">logical cell content</a> of the new columns are obtained by applying a <dfn id="dfn-function">function</dfn>, specified by the <a href="#dr:function"><code>dr:function</code></a> property. The value of <a href="#dr:function"><code>dr:function</code></a> must be a IRI that identifies a certain function. A function may return a single logical column, or multiple logical columns, each possibly consisting of one or more value elements. Reference to that logical column in <a href="#dfn-value-map">value maps</a> is achieved using the <a href="#dfn-column-name">column name</a> or, in case of multiple logical columns using the expression <i><code>defined-column-name.subcolumn name</code></i> where <i><code>subcolumn-name</code></i> is a name provided by the function to the column it returns. If a defined column returns a single column, it is accessible by default also by the expression <i><code>defined-column-name</code></i><code>.result</code>. A list of supported function is given in the <a href="#defined-column-functions">Functions</a> section.</p>

			<p>In the following example, the <a href="#drop:extractMatch"><code>drop:extractMatch</code></a> function is used. Because the <code>regex</code> parameter has two capturing groups, each logical row will be extended by two additional logical columns, accessible by the <code>ADDRESS.match#1</code> and <code>ADDRESS.match#2</code> column names.</p>

			<div class="marker" id="ex-defined-column">
				<pre class="example" title="Defined column example."><code>
<#DataMapping>  
   dr:logicalArray [ 
      a dr:JSONItemArray;
      dr:source <#DataSource> ;
      dr:iterator "$.results" ;
   ] ;
   
   dr:definedColumn [
      a dr:DefinedColumn ;
      dr:name "ADDRESS" ;
      dr:function drop:extractMatch ; 
      dr:parameterBinding [ 
         dr:parameterName "input" ;
         rr:column "$.address" ;   
      ] ;
      dr:parameterBinding [ 
         dr:parameterName "regex" ;
         rr:constant "^(.*?)(?:\\s+([0-9]+\\s?[A-Z]?))?$"  ;
      ] ; 
   ]    
   dr:predicateObjectMap [
      dr:predicate ex:streetName ;
      dr:objectMap [
         rr:column "ADDRESS.match#1" ;
         rr:termType rr:Literal ;
      ] ;
   ] ;
   ...
				</code></pre>
			</div>
		</section>

		<section id="sec-transformations">
			<h3>Transformations</h3>
				
			<p>A <dfn id="dfn-transformation">transformation</dfn> represents a set of one or more logical columns added to the current logical array or table for by obtaining additional content from a <a href="#dfn-logical-table">logical table</a> or <a href="#dfn-logical-array">logical array</a>. The underlying  of <a href="#dfn-information-source">information source</a> of the logical table or a logical array of a transformation may be different from that of the underlying <a href="#dfn-logical-table">mapping dataset</a>.</p>
			
			<p>The logical table or logical array of a transformation is provided by the <a href="#dr:logicalData"><code>dr:logicalData</code></a> property whose value is an instance of <a href="#dr:LogicalData"><code>dr:LogicalData</code></a>. An instance of  <a href="#dr:LogicalData"><code>dr:LogicalData</code></a>, simply specifies the relevant logical table or logical array, together with the parameters for which bindings should be provided by transformations. As in the case of defined columns, the values to theses parameters are supplied by <a href="dfn-parameter-binding">parameter bindings</a> than bind a parameter name to value constructed from the logical columns a logical row.</p>
				
				
			<p>Since a transformation fetches data an <a href="#dfn-information-source">information source</a>, the interpretation of the data is the on provided by the logical table or logical array specification include in the relevant <a href="#dr:LogicalData"><code>dr:LogicalData</code></a> instance. The data provided by a transformation for each logical row are accessible through the expression <code>transformation-name~~column-name</code> where <code>transformation-name</code> is the name provide in the definition of the transformation, and <code>column-name</code> a name of a logical column of the logical table or logical array provided by the transformation.</p>
		
			<p>In the following example, <code><#MappingDataset></code> applies on its underlying logical rows uses a transformation, with a single parameter, <code>wikilink</code>, which is used to formulate a query a the corresponding Wikidata SPARQL Endpoint in order to obtain the respective Wikidata URI. It is assumed that the logical list of <code><#MappingDataset></code> includes a column named <code>WIKIPEDIA-LINK</code> that contains wikipedia URIs.</p>
				
			<div class="marker" id="ex-trasnformation">
				<pre class="example" title="A transformation example."><code>
<#WikidataData>
   a dr:LogicalData
   rr:logicalTable [ 
      dr:source <#WikidataEndpoint> ;
      dr:sparqlSelectQuery "PREFIX schema: <http://schema.org/> PREFIX wdt: <http://www.wikidata.org/prop/direct/> SELECT ?wikidataId WHERE { <{@@wikilink@@}> schema:about ?wikidataId }" ;  
   ] ;
   dr:parameter [ 
      a dr:DataParameter  ;
      dr:name "wikilink" ;
   ] .

<#MappingDataset>
...
   dr:transformation [
      a dr:Transformation ;   
      dr:logicalData <#WikidataData> ;
      dr:name "WIKI-TRANSFORMATION"
      dr:parameterBinding [ 
         dr:parameterName "wikilink" ;
         rr:column "WIKIPEDIA-LINK" ;
      ] ;
   ] ;
   dr:predicateObjectMap [
      dr:predicate ex:wikidataLink ;
      dr:objectMap [
         rr:column "WIKI-TRANSFORMATION~~wikidataId" ;
         rr:termType rr:IRI ;
      ] ;
   ] ;
...
				</code></pre>
			</div>
		</section>
		
	</section>
	
	<section id="output-datasets">
		<h2>Output Datasets</h2>
		
		<p>An <dfn id="dfn-output-dataset">output dataset</dfn> is a set of data that can be serialized to one or more files. The abstract class of all output datasets is  <a href="#dr:OutputDataset"><code>dr:OutputDataset</code></a>. An output dataset is linked with a <a href="#dfn-logical-output">logical output</a> which will be used for the serialization through a <a href="#dr:logicalOutputMap"><code>dr:logicalOutputMap</code></a> property. An output dataset <em class="rfc2119">MAY</em> have zero or more <a href="#dr:logicalOutputMap"><code>dr:logicalOutputMap</code></a> properties. The shortcut property <a href="#dr:logicalOutput"><code>dr:logicalOutput</code></a> is also provided; <code>?x dr:logicalOutput ?y </code> is a shortcut for <code>?x dr:logicalOutputMap [ rr:constant ?y ]</code>.</p>
		
		An output dataset can be either a <a href="#dfn-triples-map">triples map</a>, an <a href="#dfn-rdf-map">RDF map</a>, a <a href="#dfn-text-lines-map">text lines map</a>, or a <a href="#dfn-triples-dataset">triples dataset</a>. If an <a href="#dfn-triples-map">triples map</a>, a <a href="#dfn-rdf-map">RDF map</a>, a <a href="#dfn-text-lines-map">text lines map</a> does not have a <a href="#dr:logicalOutputMap"><code>dr:logicalOutputMap</code></a> property, the <a href="#dfn-d2rml-processor">D2RML processor</a> will use the <a href="#dfn-default-rdf-output">default RDF output</a>; if an <a href="#dfn-text-lines-map">text lines map</a> does not have a <a href="#dr:logicalOutputMap"><code>dr:logicalOutputMap</code></a> property, the <a href="#dfn-d2rml-processor">D2RML processor</a> will use the <a href="#dfn-default-plain-text-output">default plain text output</a>.
	</section>
<!--		
		<section id="sec-triples-datasets">
			<h3>Triples Datasets</h3>
			
			<p>A <dfn id="dfn-triples-dataset">triples dataset</dfn> is a set of triples represented by a <a href="#dfn-logical-graph">logical graph</a>. A triples dataset <em class="rfc2119">MUST</em> contain exactly one logical graph, provided by the <a href="#dr:logicalGraph"><code>dr:logicalGraph</code></a> property. The triples in the logical graph will be included as they are in the RDF dataset produced by the D2RML processor (after possible adding them to the specified named graphs).</p>
			
			The output of the below D2RML document will be just the triples contained in <code>c:/data/dataset.ttl</code>.
			
			<div class="marker" id="ex-triples-dataset">
				<pre class="example" title="A triples dataset obtained from a TTL file."><code>
<#TRIGFile>
   a dris:FileSource ;
   dris:path "c:/data/dataset.ttl" .

<#LogicalDataset> 
   a dr:TriplesDataset
   dr:logicalGraph [
      dr:source <#TRIGFile>
   ] .
				</code></pre>
			</div>
			
		</section>
		
		<em class="rfc2119">MAY</em>
		
		If it has none, the <dfn id="dfn-default-output-dataset">output dataset</dfn>
		
	</section>-->

	<section id="maps">
		<h2>Maps</h2>
		
		<!--<p>Value maps are a mechanism for accessing specific data from logical rows, and producing output content.</p>-->
		
		<section>
			<h3>Value Maps</h3>
			
			<p>Each <a href="#dfn-logical-row">logical row</a> of a <a href="#dfn-logical-array">logical array</a> or <a href="#dfn-logical-table">logical table</a> consists of one or more <a href="#dfn-logical-column">logical columns</a>, the contents of which are accessible using a <a href="#dfn-column-name">column name</a>. Each logical column within a logical row represents a <dfn id="dfn-logical-cell">logical cell</dfn>. The <dfn id="dfn-logical-cell-content">logical cell content</dfn> is an ordered set of zero or more value elements, which is obtained by evaluating the respective <a href="#dfn-column-name">column name</a> expression against the contents of the current <a href="#dfn-logical-row">logical row</a>.</p>

		<!--<figure id="fig-value-maps"><img src="term-maps.png" alt="Logical Inputs">
			<figcaption><span class="fig-title">Value Map classes.</span></figcaption> 
		</figure> -->

			<p>In the case of <a href="#dfn-logical-table">logical tables</a>, logical cell contents consist of at most one value element, since the underlying data structure is tabular and evaluating a column name returns that value element. However, in the case of <a href="#dfn-logical-array">logical arrays</a>, logical cell contents may consist of more than one value elements. Since in this case the <a href="#dfn-column-name">column name</a>  expression may be e.g. a JSONPath or XPath expression, and its evaluation in general returns an array of objects, these objects are the value elements in the corresponding logical cell content, in the order returned by the evaluating expression.<p>
		
<!--		<p>The <dfn id="dfn-value-type">value type</dfn> of the value elements in logical cell contents can be either <a href="#dfn-string">string</a> or <a href="#dfn-IRI">IRI</a> or <a href="#dfn-Literal">literal</a>.</p> -->

			<p>The <dfn id="dfn-value-type">value type</dfn> of the value elements in logical cell contents can be either <a href="#dfn-iri">IRI</a> or <a href="#dfn-literal">literal</a>.</p> 
		
			<p>The actual values to be used for generating RDF triples are obtained from the value elements of logical cell contents, through value maps. A <dfn id="dfn-value-map">value map</dfn> is a rule for transforming the value elements of logical cell contents into a value set, where a <dfn id="dfn-value-set">value set</dfn> is an ordered set or zero or more value elements.</p>

<!--		The value set for each logical cell is obtained by evaluating the respective <a href="#dfn-column-name">column name</a> expression against the contents of the current <a href="#dfn-logical-row">logical row</a>.</p> -->

			<p>A <a href="#dfn-value-map">value map</a> can be either a <a href="#dfn-constant-value-map">constant value map</a>, or a <a href="#dfn-constant-list-value-map">constant list value map</a>, or a <a href="#dfn-column-value-map">column value map</a> or a <a href="#dfn-template-value-map">template value map</a>, which reflects the way the corresponding value set is created. In this respect, the type of a value map is determined by the appearance of <a href="#rr:constant"><code>rr:constant</code></a>, <a href="#dr:constantList"><code>dr:constantList</code></a>, <a href="#rr:column"><code>rr:column</code></a> and <a href="#rr:template"><code>rr:template</code></a> property, respectively. Any value map must have exactly one of those properties.</p>
		
			<p>A value map specify also a <dfn id="dfn-join-string">join string</a>, though the <a href="#dr:joinString"><code>dr:joinString</code></a> property. In this case, the value set will consist of one element, that will be the concatenation of the original elements of the value set, separated by the join string.</p>
			
<!--		<section id="value-set-creation">
			<h3>Value Set Creation</h3> -->
			
			<section id="sec-constant-value-map"> 
				<h3>Constant and Constant List Value Maps</h3>
			
				<p>A <dfn id="dfn-constant-value-map">constant value map</dfn> generates a <a href="#dfn-value-set">value set</a> by ignoring the <a href="#dfn-logical-cell">logical cells</a> of the current <a href="#dfn-logical-row">logical row</a> and adding to it a single fixed value. The only element of the value set of a constant value map is provided by the <a href="#rr:constant"><code>rr:constant</code></a> property.</p>

				<p>A <dfn id="dfn-constant-list-value-map">constant list value map</dfn> generates a <a href="#dfn-value-set">value set</a> by ignoring the <a href="#dfn-logical-cell">logical cells</a> of the current <a href="#dfn-logical-row">logical row</a> and adding to it a number of fixed values. The elements of the value set of a constant list value map are the values provided by the <a href="#dr:constantList"><code>dr:constantList</code></a> property, which should be an RDF list. The order of the elements is preserved in the value set.</p>
			
				<p>The <a href="#dfn-value-type">value type</a> of the value set elements of a <a href="#dfn-constant-value-map">constant value map</a> or a <a href="#dfn-constant-list-value-map">constant list value map</a> is either <a href="#dfn-IRI">IRI</a> or <a href="#dfn-literal">literal</a>. If it is a literal, its <a href="#dfn-datatype">datatype</a> is determined by the literal.</p>
			
			</section>
			
			<section id="sec-column-value-map"> 
				<h3>Column Value Maps</h3>

				<p>A <dfn id="dfn-column-value-map">column value map</dfn> generates a <a href="#dfn-value-set">value set</a> by copying to it all elements of a <a href="#dfn-logical-cell-content">logical cell content</a>. The <a href="#dfn-logical-column">logical column</a> of that logical cell is the logical column addressable by the <a href="#dfn-column-name">column name</a> expression that is the value of the <a href="#rr:column"><code>rr:column</code></a> property.
			
				<p>The <a href="#dfn-value-type">value type</a> of the value set elements of a <a href="#dfn-column-value-map">column value map</a> is <a href="#dfn-IRI">IRI</a> or <a href="#dfn-literal">literal</a> if the underlying logical input is a <a href="#dfn-sparql-query-result">SPARQL query result</a>, and a <a href="#dfn-literal">literal</a> with <a href="#dfn-datatype">datatype</a> <a href="https://www.w3.org/TR/xmlschema11-2/#string"><code>xsd:string</code></a> otherwise.</p>
			</section>

			<section id="sec-template-value-map"> 
				<h3>Template Value Maps</h3>
			
				<p>A <dfn id="dfn-template-value-map">template value map</dfn> generates a <a href="#dfn-value-set">value set</a> by concatenating  elements of one or more <a href="#dfn-logical-cell-content">logical cell contents</a> and possibly also fixed strings. The way the elements will be concatenated is determined by a <dfn id="dfn-string-template">string template</dfn> that is the value of the <a href="#rr:template"><code>rr:template</code></a> property. A string template contains fixed string parts and it can reference <a href="#dfn-column-name">column names</a> by enclosing them in curly braces <code>{ ... }</code>. If the logical cell content of a column name involved in a string template is empty, the resulting value set is empty. If some logical cell contents contain more than one value elements, the resulting value set contains all values obtained by substituting the column names in the string template in all possible ways. A namespace defined in the D2RML document can be reference from within a string template by as <code>{@namespace-prefix}</code> where <code>namespace-prefix</code> is the prefix of a defined namespace.</p>
			
<!--			Details about conversion to string...-->

				<p>For example, if the source data for logical row is the following JSON object</p>
				<pre class="ex-data"><code>
{ "companies": [ "COMP1", "COMP2" ] }, {"employees": [ "EMP1", "EMP2" ] }
				</code></pre>
			
				<p>and assuming the definition <code>@prefix ex: &lt;http://data.example.com/&gt;</code>, the value set generated for the string template</p>
			
				<pre class="ex-mapping"><code>
"{@ex}{$.companies}/{$.employees}"
				</code></pre>

				<p>will contain the following value elements.</p>
			
				<pre class="ex-output"><code class="none">
"http://data.example.com/COMP1/EMP1"
"http://data.example.com/COMP1/EMP2"
"http://data.example.com/COMP2/EMP1"
"http://data.example.com/COMP1/EMP2"
				</code></pre>
			
				<p>The value type of the value set elements of a <a href="#dfn-template-value-map">template value map</a> is <a href="#dfn-literal">literal</a> with <a href="#dfn-datatype">datatype</a> <a href="https://www.w3.org/TR/xmlschema11-2/#string"><code>xsd:string</code></a>.</p>

				<p>As mentioned before, if the logical cell content of a column name involved in a <a href="#dfn-string-template">string template</a> is empty, the resulting value set is empty. If this is the case the values set that will be generated will be empty. However, a string template may contain also <a href="#dfn-optional-template-parts">optional template parts</a>, that act as usual fixed parts, but if the resulting expression is empty, it is just ignore and does not cause the entire value set of the template to be empty. Optional template parts are enclosed within <code>&lt;&lt;...&gt;&gt;</code>.
			
				<p>Extending the above example, if the source data for logical row is the following JSON object</p>
				<pre class="ex-data"><code>
{ "companies": [ "COMP1", "COMP2" ] }, {"employees": [ "EMP1", "EMP2" ] }, {"departments": [  ] }
				</code></pre>
			
				<p>the value set generated for the string template</p>
			
				<pre class="ex-mapping"><code>
"{@ex}{$.companies}&lt;&lt;-{$.departments}&gt;&gt;/{$.employees}"
				</code></pre>

				<p>will be the same value elements as before because <code>{$.departments}</code> despite having an empty value set is inside an optional template part.</p>
			
				<p>A string template can also contain references to <a href="#dfn-external-parameter">external parameters</a>. Using the convention for parameters they may referenced as <code>{@@parameter-name@@}</code> for an external parameter with name <code>parameter-name</code> and the expression will be substituted by the value provided to the parameter.</p>
		
		</section>
		
<!--		<section>
			<h3>Value Set Interpretation</h3>
			
			<p>The elements of value sets are are <a href="#dfn-IRI">IRIs</a> or <a href="#dfn-literal">literals</a> in general used to generate RDF terms, so in general additional information is needed to convert the elements of value sets to RDF terms.</p>
			
			
		</section> -->
		
			<section>
				<h3>Conditional Value Maps</h3>
				
				 <p>A <a href="#dfn-value-map">value map</a> may be a <dfn id="dfn-conditional-value-map">conditional value map</dfn>, in which case the <a href="#dfn-value-set">value set</a> generated by it is dependent on the satisfaction of a condition. The condition is specified by a <a href="#dr:condition"><code>dr:condition</code></a> property whose value is an instance of <a href="#dr:Condition"><code>dr:Condition</code></a>. If the condition evaluates to false the corresponding value set is empty. A conditional value map may be specified also using a <a href="#dr:cases"><code>dr:cases</code></a> or <a href="#dr:exclusiveCases"><code>dr:exclusiveCases</code></a> property. The value of each one of this properties is a list of <a id="#dfn-conditional-value-map">conditional value map</a> having a <a href="#dr:condition"><code>dr:condition</code></a> property, apart possibly from the last one that may not have a condition. The several value maps are evaluated one by one, and if the corresponding condition evaluated to true, the resulting values are added to the value set of the value map. In the case of the <a href="#dr:exclusiveCases"><code>dr:exclusiveCases</code></a> the evaluation stops at first value map that evaluated to true.</p>
			</section>
		</section>
		
		<section>
			<h3>Term Maps</h3>
			
			<p>A <dfn id="dfn-term-map">term map</dfn> is a <a href="#dfn-value-map">value map</a> that is a rule for generating one or more RDF terms from a <a href="#dfn-logical-row">logical row</a>. The value elements that will give rise to the RDF terms are the elements of the underlying <a href="#dfn-value-set">value set</a> which is created as described above. A term map supplies all necessary information to generate the final RDF terms from the value set.</p>

			<p>Each term map has a <dfn id="dfn-term-type">term type</dfn>, which determines the kind of the generated RDF terms, i.e. whether they will be IRIs, blank nodes or literals. The term type is specified by the <a href="#rr:class"><code>rr:termType</code></a> property, whose value <em class="rfc2119">MUST</em> be one of <a href="#rr:IRI"><code>rr:IRI</code></a>, <a href="#rr:BlankNode"><code>rr:BlankNode</code></a> or <a href="#rr:Literal"><code>rr:Literal</code></a>.</p>

			
			<section>
				<h3>Subject Maps</h3>
				
				<p>A <dfn id="dfn-subject-map">subject map</dfn> is a <a href="#dfn-term-map">term map</a> that is a rule for generating the subjects of the RDF triples generated by a triples map for each logical row. These subjects are the value elements of the underlying <a href="#dfn-value-set">value set</a>. The <a href="#dfn-term-type">term type</a> of a subject map must be either <a href="#dfn-IRI">IRI</a> or <a href="#dfn-blank-node">blank node</a>.</p>
				
				<p>A <a href="#dfn-subject-map">subject map</a> <em class="rfc2119">MAY</em> have one or more class IRIs. They are defined by the <a href="#rr:class"><code>rr:class</code></a> property. The values of the <a href="#rr:class"><code>rr:class</code></a> property <em class="rfc2119">MUST</em> be <a href="#dfn-IRI">IRIs</a>. For each RDF term generated by the subject map, RDF triples with predicate rdf:type and the class IRI as object will be generated.</p>
				
				<div class="marker" id="ex-subject-map">
					<pre class="example" title="A subject map."><code>
<#Mapping>  
   rr:logicalTable [ 
      a dr:CSVTable;
      dr:source <#DataSource> ;
	  dr:headerRecord true;
	  dr:delimiter ",";
   ] ;
   
   rr:subjectMap [ 
      rr:template  "http://ex.org/{ID}" ;
      rr:class ex:Company ;
   ] ;
					</code></pre>		
				</div>
			</section>
			
			<section>
				<h3>Predicate Maps</h3>
				
				<p>A <dfn id="dfn-predicate-map">predicate map</dfn> is a <a href="#dfn-term-map">term map</a> that is a rule for generating the predicate of the RDF triples generated by a triples map for each logical row. These predicates are the value elements of the underlying <a href="#dfn-value-set">value set</a>. The <a href="#dfn-term-type">term type</a> of a predicate map <em class="rfc2119">MUST</em> be <a href="#dfn-IRI">IRI</a>, and hence its specification can be omitted.</p>
				
				<div class="marker" id="ex-cases-1">
					<pre class="example" title="A conditional predicate map with a condition."><code>
rr:predicateMap [
   rr:constant ex:main ;
   dr:condition [
       rr:column  "TYPE_ID" ;
       drop:eq "1" ;
   ] ;
] 
					</code></pre>			
				</div>
			
				<div class="marker" id="ex-cases-2">
					<pre class="example" title="A conditional predicate map with cases."><code>
rr:predicateMap [
   dr:cases ( [
      rr:constant ex:main ;
      dr:condition [
        rr:column  "TYPE_ID" ;
           drop:eq "1" ;
        ] ;
   ] [
      rr:constant ex:secondary ;
      dr:condition [
         rr:column  "TYPE_ID" ;
         drop:eq "2" ;
      ] ;
   ] [
      rr:constant ex:other ;
   ] )
] 
					</code></pre>					
				</div>
			</section>

			<section>
				<h3>Object Maps</h3>
				
				<p>A <dfn id="dfn-object-map">object map</dfn> is a <a href="#dfn-term-map">term map</a> that is a rule for generating the objects of the RDF triples generated by a triples map for each logical row. These values are IRIs or literals constructed from the elements of the underlying <a href="#dfn-value-set">value set</a>. The <a href="#dfn-term-type">term type</a> of a flat object map is either <a href="#dfn-IRI">IRI</a> or <a href="#dfn-blank-node">blank node</a> or <a href="#dfn-literal">literal</a>.</p>
				
				<p>If the <a href="#dfn-term-type">term type</a> is <a href="#dfn-literal">literal</a>, and the value type of elements of the <a href="#dfn-value-set">value set</a> is <a href="https://www.w3.org/TR/xmlschema11-2/#string"><code>xsd:string</code></a>, then the value elements are interpreted as the lexical form of the literal to be generated. A different <a href="#dfn-datatype">datatype</a> can be assigned through the <a href="#rr:datatype"><code>rr:datatype</code></a> property. Also, in case of string value, a language can be specified by the <a href="#dr:languageMap"><code>dr:languageMap</code></a>. The shortcut property <a href="#rr:language"><code>rr:language</code></a> is also provided; <code>?x rr:language ?y </code> is a shortcut for <code>?x dr:languageMap [ rr:constant ?y ]</code>.</p>
				
				<div class="marker" id="ex-object-map">
					<pre class="example" title="A literal object map."><code>
rr:objectMap  [ 
   rr:column "name" ;
   rr:termType  rr:Literal ;
   rr:language "en" 
] ;
					</code></pre>					
				</div>
	  
			</section>
			
			<section>
				<h3>Graph Maps</h3>
				
				<p>A <dfn id="dfn-graph-map">graph map</dfn> is a <a href="#dfn-term-map">term map</a> that is a rule for generating the named graph to which the relevant RDF triples generated by a triples map will be included. These named graphs are the value elements of the underlying <a href="#dfn-value-set">value set</a>. The <a href="#dfn-term-type">term type</a> of a graph map <em class="rfc2119">MUST</em> be <a href="#dfn-IRI">IRI</a>.</p>
				
			</section>

			<section>
				<h3>Logical Output Maps</h3>
				
				<p>A <dfn id="dfn-logical-output-map">logical output map</dfn> is a <a href="#dfn-term-map">term map</a> that is a rule for generating the logical output to which the relevant RDF triples generated by a triples map will be directed. A logical output map should generate a IRI, that should be a <a href="#dfn-logical-output">logical output</a>. The <a href="#dfn-term-type">term type</a> of a logical output map <em class="rfc2119">MUST</em> be <a href="#dfn-IRI">IRI</a>.</p>
				
				<div class="marker" id="ex-logical-output-map">
					<pre class="example" title="Logical output map example."><code>
<#Output1> 
  a dr:RDFOutput ;
  dr:name "NEW" .

<#Output2> 
  a dr:RDFOutput ;
  dr:name "CHANGES" .

<#UpdateMapping>  
   dr:logicalArray [ 
      a dr:JSONItemArray;
      dr:source <#UpdateSource> ;
      dr:iterator "$.results" ;
   ] ;
   
   dr:logicalOutputMap [
      dr:cases ( [
         rr:constant  <#Output1> ;
         dr:condition [
            rr:column "$.updateType" ;
            drop:eq "New" ;
         ] ;
      ] [
         rr:constant  <#Output2>  ;
         dr:condition [
            rr:column "$.updateType" ;
            drop:eq "Changed" ;
         ] ;
      ]
   ] ;
   
   ...
					</code></pre>	
				</div>
			
			</section>
			
		</section>
		
		<section>
			<h3>Language Maps</h3>
			
			<p>A <dfn id="dfn-language-map">language map</dfn> is a <a href="#dfn-value-map">value map</a> that is a rule for generating language tags to be used in RDF literals. These language tags are the value elements of the underlying <a href="#dfn-value-set">value set</a>.</p>
			
			<div class="marker" id="ex-object-map-language-map">
				<pre class="example" title="An object map with a language map."><code>
rr:objectMap  [ 
   rr:column "name" ;
   rr:termType  rr:Literal ;
   rr:languagMap [
      dr:cases ( [
         rr:constant "fr" ;
         dr:condition [
            rr:column  "Language" ;
            drop:eq "1" ;
         ] ;
      ] [
         rr:constant "nl" ;
         dr:condition [
            rr:column  "Language" ;
            drop:eq "2" ;
         ] ;
      ]  ;   
   ] );  
] 
				</code></pre>		
			</div>
			
		</section>				
		
		<section>
			<h3>Parameter Bindings</h3>
			
			<p>A <dfn id="dfn-parameter-binding">parameter binding</dfn> is a <a href="#dfn-value-map">value map</a> that is a rule for binding parameter names to the value. The values are the value elements of the underlying <a href="#dfn-value-set">value set</a>. A parameter map must include a <a href="#dr:parameterName"><code>dr:parameterName</code></a> property, which determined the name of the parameter for which the binding will be generated.</p>
			
		</section>	
		
		<section>
			<h3>Conditions</h3>
			
			<p>A <dfn id="dfn-condition">condition</dfn> is a <a href="#dfn-value-map">value map</a> that represents an expression that evaluates to true or false.</p>
			
		</section>	
		
		<section id="sec-predicate-object-maps">
			<h3>Predicate Object Maps</h3>
			
			<p>A <dfn id="dfn-predicate-object-map">predicate object map</dfn> is a rule for generating the predicate and object of triples from a <a href="#dfn-logical-row">logical row</a> of a <a href="#dfn-logical-array">logical array</a> or <a href="#dfn-logical-table">logical table</a>. It must appear within a <a href="#dfn-triples-map">triples map</a>, and it must specify one or more <a href="#dfn-predicate-map">predicate maps</a> using the <a href="#rr:predicateMap"><code>rr:predicateMap</code></a> property for generating the predicates, and one or more <a href="#dfn-object-map">object maps</a> using the <a href="#rr:objectMap"><code>rr:objectMap</code></a> property for generating the objects. A predicate map generates all possible triples having as subject an element of the enclosing <a href="#dfn-subject-map">subject map</a>, as predicate an element of the predicate maps it contains, and as object an element of the objects maps it contains.</p>
			
			<p>The shortcut properties <a href="#rr:predicate"><code>rr:predicate</code></a> and <a href="#rr:object"><code>rr:object</code></a> are also provided; <code>?x rr:predicate ?y </code> is a shortcut for <code>?x rr:predicateMap [ rr:constant ?y ]</code>, and <code>?x rr:object ?y </code> is a shortcut for <code>?x rr:objectMap [ rr:constant ?y ]</code>.</p>
			
			
		</section>
		
<!--
	<section id="logical-datasets">
		<h2>Logical Datasets</h2>
		
		<p>A <dfn id="dfn-logical-dataset">logical dataset</dfn> represents a specification for the generation of an actual RDF dataset as defined in [[RDF11-CONCEPTS]]. The specification of a particular logical dataset provides to the D2RML processor all necessary instructions on how to generate the actual RDF triples or quads pertaining to the RDF dataset.</p>
		
		<p>The abstract class of all logical datasets is <a href="#dr:LogicalDataset"><code>dr:LogicalDataset</code></a>. A logical dataset can be either a <a href="#dfn-triples-dataset">triples map</a> or a <a href="#dfn-triples-dataset">triples dataset</a>. The first represents a set of rules for generating an RDF dataset, while the second represents (a modification of) an existing RDF dataset. Apart from the other properties discussed below, a logical dataset may include one or more <a href="#dfn-graph-map">graph maps</code></a>, through the <a href="#dr:graphMap"><code>dr:graphMap</code></a> property, to specify the named graphs to which all triples of the logical dataset will be added.</p>
		
		<p>By default, the D2RML processor places the RDF triples or quads produced for a logical dataset to the <a href="#dfn-default-output">default output</a>. If a logical dataset is used for auxiliary purposes, the <a href="#dr:target"><code>dr:target</code></a> property allows the D2RML document to instruct the D2RML processor to place the triples or quads to a temporary <a href="#dfn-memory-store">memory store</a>.</p>
		
		<figure id="fig-logical-datasets"><img src="logical-datasets.png" alt="Logical Datasets">
			<figcaption><span class="fig-title">Logical dataset related classes.</span></figcaption> 
		</figure>

-->

		<section id="triples-map">
			<h3>Triples Map</h3>
			
			<p>A <dfn id="dfn-triples-map">triples map</dfn> represents a rule for obtaining from each <a href="#dfn-logical-row">logical row</a> of a <a href="#dfn-logical-array">logical array</a> or <a href="#dfn-logical-table">logical table</a> zero or more RDF triples. A triples map uses the logical array or logical table, provided by the <a href="#dr:logicalArray"><code>dr:logicalArray</code></a> and <a href="#dr:logicalTable"><code>dr:logicalTable</code></a>, respectively, of the enclosing <a href="#dfn-mapping-dataset">mapping dataset</a>.</p>
			
			<p>Apart from the other properties discussed below, a logical dataset may include one or more <a href="#dfn-graph-map">graph maps</a>, through the <a href="#rr:graphMap"><code>rr:graphMap</code></a> property, to specify the named graphs to which all triples of the logical dataset will be added.</p>
			
<!--			<p>As discussed above, each <a href="#dfn-logical-row">logical row</a> consists of one or more <a href="#dfn-logical-column">logical columns</a>, the contents of which are accessible using a <a href="#dfn-column-name">column name</a>. And each logical column within a logical row (a <a href="#dfn-logical-cell">logical cell</a>) may contain zero or or more values since it is a <a href="#dfn-value-set">value set</a>.</p> -->
			
			<p>RDF triples are generated from the underlying <a href="#dfn-logical-array">logical array</a> or <a href="#dfn-logical-table">logical table</a>, possibly extended by <a href="#dfn-logical-extension">logical extensions</a> using a combination of a <a href="#dfn-subject-map">subject map</a> and zero or more <a href="#dfn-predicate-object-map">predicate object map</a>. A <a href="#dfn-triples-map">triples map</a> <em class="rfc2119">MUST</em> contain at least one <a href="#dfn-subject-map">subject map</a>.</p>
			
			<p>The <a href="#dfn-subject-map">subject map</a> is provided by the  <a href="#rr:subjectMap"><code>rr:subjectMap</code></a> property, which provides the subjects of the triples to be generated. The <a href="#dfn-predicate-object-map">predicate object maps</a> are provided using the <a href="#rr:predicateObjectMap"><code>rr:predicateObjectMap</code></a> property, which provide the predicate and objects of the triples. For each <a href="#dfn-predicate-object-map">predicate object map</a>, an RDF triple is generated for each possible combination <code>subject</code> <code>predicate</code> <code>object</code>, where <code>subject</code> belongs to the <a href="#dfn-value-set">value set</a> of the <a href="#dfn-subject-map">subject map</a>, <code>predicate</code> belongs to the <a href="#dfn-value-set">value set</a> of some <a href="#dfn-predicate-map">predicate map</a> of the predicate object map and <code>object</code> belongs to the <a href="#dfn-value-set">value set</a> of some <a href="#dfn-object-map">object map</a> of the predicate object map. All value sets may contain zero or more value elements. The shortcut properties <a href="#rr:predicate"><code>rr:predicate</code></a> and <a href="#rr:object"><code>rr:object</code></a> are also provided; <code>?x rr:predicate ?y </code> is a shortcut for <code>?x dr:predicateMap [ rr:constant ?y ]</code> and <code>?x rr:object ?y </code> is a shortcut for <code>?x dr:objectMap [ rr:constant ?y ]</code>.</p>

			<p>If a <a href="#dfn-triples-map">triples map</a> defined a <a href="#dfn-predicate-object-map">predicate object map</a> using the <a href="#dr:inversePredicateObjectMap"><code>dr:inversePredicateObjectMap</code></a> then, for each possible combination as above, the RDF triple <code>object</code> <code>predicate</code> <code>subject</code> will be generated.</p>
				

		</section> 
		
		<section>
			<h3>RDF Maps</h3>
			
			<p>An <dfn id="dfn-rdf-map">RDF map</dfn> is a <a href="#dfn-value-map">value map</a> that is used in the cases where the value elements of the underlying <a href="#dfn-value-set">value set</a> are serializations of RDF graphs. The RDF serialization format is determined by the <a href="#dr:rdfFormat"><code>dr:rdfFormat</code></a> property.</p>

			<p>All triples of the underlying RDF graphs will be added as they are in the <a href="#dfn-output-dataset">output dataset</a>, unless the RDF map contains a <a href="#dr:sparqlUpdateQuery"><code>dr:sparqlUpdateQuery</code></a> or <a href="#dr:sparqlUpdateQueries"><code>dr:sparqlUpdateQueries</code></a> property, in which case the actions prescribed be the queries will be first applied on the RDF graphs.</p>
			
			<p><a href="#dfn-rdf-map">RDF maps</a> are within <a href="#dfn-mapping-dataset">mapping datasets</a> and they are provided by the <a href="#dr:rdfMap"><code>dr:rdfMap</code></a> property. <!--All triples represented by the RDF map, are  generated by the triples map.--></p>
			
			<div class="marker">
				<pre class="example" title="RDF map example."><code>
<#DataSource>
   a dris:HTTPSource ;
   dris:uri "http://www.example.org/data/data.rdf" .

<#Mapping>
   dr:logicalArray [ 
      a dr:XMLItemArray ;
      dr:source <#DataSource> ;
      dr:iterator "/rdf:RDF"
   ] ;
   dr:rdfMap [
      rr:column "/rdf:RDF/ore:Proxy" ;
      dr:rdfFormat formats:RDF_XML 
   ] .
			</code></pre>				
			</div>		
			
			<p>In the above example, the data source is an RDF/XML file, which is interpreted as an XML file, and the RDF map specifies that in the logical output will be included only the contents of the <code>/rdf:RDF/ore:Proxy</code> XML elements, interpreted as RDF graphs in the RDF/XML serialization.</p>
		</section>

		<section>
			<h3>Text Lines Maps</h3>
			
			<p>An <dfn id="dfn-text-lines-map">text lines map</dfn> is a rule for generating text lines from a <a href="#dfn-logical-row">logical row</a> of a <a href="#dfn-logical-array">logical array</a> or <a href="#dfn-logical-table">logical table</a>. 
			
			<div class="marker">
				<pre class="example" title="Text line map example."><code>
<#SPARQLOutput> 
   a dr:PlainTextOutput ;
   dr:outputName "SPARQL" .
<#UpdateMapping>  
   dr:logicalArray [ 
      a dr:JSONItemArray;
      dr:source <#UpdateSource> ;
      dr:iterator "$.results" ;
   ] ;
   
   dr:textLinesMap [
      dr:logicalOutput <#SPARQLOutput> ;
      rr:template "DELETE {{ &lt;http://ex.org/id/{$.id}&gt; ?p ?q . ?q ?r ?t }} WHERE {{ &lt;http://ex.org/id/{$.id}&gt; ?p ?q . OPTIONAL {{ ?q ?r ?t }} }}" ;
      dr:condition [
         rr:column "$.deleted" ;
         drop:eq true ;
      ] ;
   ] ;
				</code></pre>
			</div>
		</section>
		
	</section>

		
<!--		<section id="logical-term-maps">
			<h3>Term Maps</h3>
			
			<p>A <dfn id="#term-map">term map</dfn> is a function that generates an RDF term from a logical table row
			</p>
			
		</section>
-->		

<!--
		<section id="logical-dataset-order">
			<h3>Logical Dataset Order</h3>
			
			<p>In some cases, e.g. when an in-memory RDF dataset <a href="#dr:LocalDataset"><code>dr:LocalDataset</code></a> is used for storing intermediate information, the execution order of the triples maps could be important. In such cases, the D2RML Processor can be instructed in which order the logical datasets contained in a D2RML document should be processed by a <a href="#dr:LogicalDatasetOrder"><code>dr:LogicalDatasetOrder</code></a>.  A <a href="#dr:LogicalDatasetOrder"><code>dr:LogicalDatasetOrder</code></a> may also be used to specify which of the logical datasets contained in the document should be executed by the D2RML Processor. The order of logical datasets to be executed is given in a list through the <a href="#dr:logicalDatasets"><code>dr:logicalDatasets</code></a> property; any logical datasets not contained in the list will be ignored by the D2RML Processor.
			
			<p>A D2RML document <em class="rfc2119">MAY</em> contain at most one <a href="#dr:LogicalDatasetOrder"><code>dr:LogicalDatasetOrder</code></a>. If it contains none, all logical datasets defined in the document will be executed in an arbitrary order.</p>
			
			<div class="marker"> 
				<pre class="example" title="Order of execution of three triples maps."><code>
<#ProcessingOrder>
   a dr:LogicalDatasetOrder ;
   dr:logicalDatasets( <#Mapping1> <#Mapping2> <#Mapping3> ).
				</code></pre>
			</div>		

	</section> -->
		


	
	<section id="parameters">
		<h2>Parameters</h2>
		
		<p>A <dfn id="dfn-parameter">parameter</dfn> identifies a variable that is used to pass parametric information. A parameter is an instance of <a href="#dr:Parameter"><code>dr:Parameter</code></a> that is the abstract class of all parameters. A parameter is characterized by a name declared using the <a href="#dr:name"><code>dr:name</code></a> property. A parameter with name <code>name</code> can be used in a textual context as <code>{@@NAME@@}</code>. The <a href="dfn-d2rml-processor">D2RML processor</a> is responsible for computing the value of the parameter and substituting it in the string where it is used.</p>
		
		<figure id="parameters-diagram"><img src="parameters.png" alt="Parameters">
			<figcaption><span class="fig-title">Parameter classes.</span></figcaption> 
		</figure>
		
		<p>A parameter may be an <a href="#dfn-external-parameter"><code>external parameter</code></a>, a <a href="#dfn-data-parameter"><code>data parameter</code></a> or a <a href="#dfn-request-iterator"><code>request iterator</code></a>.
		
		<section id="sec-external-parameter">
			<h3>External Parameters</h3>
			
			<p>An <dfn id="dfn-external-parameter">external parameter</dfn> is parameter that is use to pass information to the <a href="dfn-d2rml-processor">D2RML processor</a> by the runtime environment.</p>
				
			<div class="marker">
				<pre class="example" title="An external parameter used by an SPARQL query result element."><code>
<#Mapping>  
   rr:logicalTable [ 
      a dr:SPARQLQueryResult ;
      dr:source <#SPARQLEndpoint> ;
      dr:sparqlQuery "SELECT ?s ?o WHERE { ?s <{@@PROPERTY@@}> ?o }" ;            
      dr:parameter [ 
         a dr:ExternalParameter;
         dr:name "PROPERTY" ;
      ] ;
   ] ;				
				</code></pre>
			</div>		
				
		</section>

		<section id="sec-data-parameter">
			<h3>Data Parameters</h3>
			
			<p>A <dfn id="dfn-data-parameter">data parameter</dfn> is a parameter that obtains its value thought binding to other results.</p>
				
			In the following example the <code><#Mapping></code> triples map gets a SPARQLQueryResult from a SPARQL endpoint, which consists of an <code>id</code> and an <code>lexicalValue</code> column. The <code>lexicalValue</code> is then send to an <code><#AnalyzeService></code>. The <code><#AnalyzeService></code> has a parametric URL which includes the parameter <code>TEXT</code>. The <code>lexicalValue</code> is sent to the <code><#AnalyzeService></code> by the <code><#AnalyzeTransformation></code> after making the necessary binding and is responsible from providing to <code><#Mapping></code> the results obtained from <code><#AnalyzeService></code>.
				
			<div class="marker"> 
				<pre class="example" title="Data variable binding example."><code>
<#AnalyzeService>
   a dris:HTTPSource ;
   dris:httpRequest [ 
      http:absoluteURI "http://www.nlp.net/analyze?text={@@TEXT@@}" ;
      http:methodName "GET" ;
   ] ;
   dr:parameter [ 
      a is:DataParameter;
      is:name "TEXT" ;
   ] .
   
<#AnalyzeTransformation>
   dr:logicalSource [ 
      dr:source <#AnazyzeService> ;
      dr:iterator "$[*]";
      dr:referenceFormulation is:JSONPath;
   ] ;	
   
<#Mapping>  
   rr:logicalTable [ 
      dr:source <#SPARQLEndpoint> ;
      dr:sparqlQuery "SELECT ?id ?lexicalValue WHERE { ?id <http://www.w3.org/2000/01/rdf-schema#label> ?label . BIND(STR(?label) AS ?lexicalValue) } }" ;            
   ]
   dr:transformation [
      dr:logicalData <#AnalyzeTransformation> ;  
      dr:name "TRANSFORMATION" ;
      dr:parameterBinding [ 
         dr:parameterName "TEXT" ;
         rr:column "lexicalValue" ;
      ] ;
   ] 
   ...
				</code></pre>
			</div>		
		</section>
		
		<section id="sec-request-iterators">
			<h3>Request Iterators</h3>
			
			<p>A request iterator may be a <a href="#dfn-enumerate-request-iterator">enumerate request iterator</a>, a <a href="#dfn-simple-count-request-iterator">simple count request iterator</a> or a <a href="#dfn-simple-key-request-iterator">simple key request iterator</a>.</p>
			
			<section id="sec-enumerate-request-iterators">
				<h3>Enumerate Request Iterators</h3>

				<p>An <dfn id="dfn-enumerate-request-iterator">enumerate request iterator</dfn> is a request iterator that takes successively all values from a predefined list of string values. The list of values is provided by the <a href="#dris:values"><code>dris:values</code></a> property.</p>
				
				<div class="marker">
					<pre class="example" title="Enumerate request iterator example."><code>
<#Source>
   a dris:HTTPSource ;
   dris:httpRequest [ 
      http:absoluteURI "https://www.museum.org/items/{@@id@@}" ;
      http:methodName "GET" ;
   ] ;
   dr:parameter [ 
      a dris:EnumerateRequestIterator;
      dr:parameterName "id" ;
      dris:values ( "photo-49" "photo-34" "document-19" "document-92" ) ;
   ] .
					</code></pre>
				</div>
			</section>
			
			<section id="sec-simple-count-request-iterator">
				<h3>Simple Count Request Iterators</h3>

				<p>An <dfn id="dfn-simple-count-request-iterator">simple count request iterator</dfn> is a request iterator that takes successively all values from an initial value up to a maximum value by the specified increment.<p>
				
				<div class="marker">
					<pre class="example" title="Count request iterator example."><code>
<#Source>
   a dris:HTTPSource ;
   dris:httpRequest [ 
      http:absoluteURI "https://www.museum.org/items?page={@@page@@}&size=20" ;
      http:methodName "GET" ;
   ] ;
   dr:parameter [ 
      a dris:SimpleCountRequestIterator;
      dr:name "id" ;
      dris:initialCount 1 ;
      dris:maxCount 100 ;
      dris:increment 20 ;
   ] .
					</code></pre>
				</div>
			</section>
			
			<section id="sec-simple-key-request-iterator">
				<h3>Simple Key Request Iterators</h3>

				<p>A <dfn id="dfn-simple-key-request-iterator">simple key request iterator</dfn> is a request iterator that takes successively some values. Each time the value is obtained from an element of the current data returned by the information source. In order for this to be possible, the data should be interpreted.</p>
				
				<p>If an HTTP source returns paginated results e.g. in the form</p>
					<pre><code>
{
   "itemsCount": 20,
   "totalResults": 567,
   "nextCursor": "K2FSDA48DSA93GH6B97F5D767KD3B08HJ",
   "items": [
      ...
   ]
}
					</code></pre>
				<p>where the value of <code>nextCursor</code> is a value that should be used in the URL to retrieve the next page, all pages can be obtained iteratively by using the following request iterator</p>

				<div class="marker">
					<pre class="example" title="Key request iterator example."><code>
<#Source>
   a dris:HTTPSource ;
   dris:httpRequest [
      http:absoluteURI "http://www.example.org/search?cursor={@@cursor@@}&rows=20" ;
      http:methodName "GET" ;
   ] ;
   dr:parameter [ 
      a dris:SimpleKeyRequestIterator ;
      dr:name "cursor" ;
      dris:initialValue "*" ;
      dr:column "$.nextCursor" ;
      dr:columnFormulation dris:JSONPath ; 
   ] .
					</code></pre>
				</div>
			</section>
			
		</section>
		
	</section>
	
	<section id="logical-outputs">
		<h2>Logical Outputs</h2>
		
		<p>A <dfn id="dfn-logical-output">logical output</dfn> represents the content produced by an <a href="dfn-output-map">output map</a>. If the data is going to be serialized, the <a href="#dfn-d2rml-processor">D2RML processor</a> is responsible for creating the necessary files for each logical output in which it will store the serialization of the respective data. Hence, for each output map, a <a href="dfn-storage-plan">storage plan</a> has to be declared to the D2RML processor, with detailed information on how the data are going to be stored, e.g. providing the path and file name.</p> 
		
		<p>The abstract class of all logical outputs is <a href="#dr:LogicalOutput"><code>dr:LogicalOutput</code></a>.
		A <a href="#dr:LogicalOutput"><code>dr:LogicalOutput</code></a> instance <em class="rfc2119">MUST</em> have a <a href="#dr:outputName"><code>dr:outputName</code></a> property, which declares to the <a href="#dfn-d2rml-processor">D2RML processor</a> a name which it will use to link the particular logical output to a <a href="dfn-storage-plan">storage plan</a>.</p>
		
		<figure id="fig-logical-outputs"><img src="logical-outputs.png" alt="Logical Outputs">
			<figcaption><span class="fig-title">Logical Output classes.</span></figcaption> 
		</figure>

		<p>A <a href="#dfn-logical-output">logical output</a> can be either an <a href="#dfn-rdf-output">RDF output</a>, or a <a href="#dfn-plain-text-output">plain text output</a>.</p>	
		
		<section id="rdf-output">
			<h3>RDF Outputs</h3>
		
			<p>An <dfn id="dfn-rdf-output">RDF output</dfn> represents an RDF dataset produced by a <a href="dfn-triples-map">triples map</a> or an <a href="dfn-rdf-map">RDF map</a>. It is an instance of <a href="#dr:RDFOutput"><code>dr:RDFOutput</code></a>. An RDF output <em class="rfc2119">MAY</em> have a <a href="#dris:fileFormat"><code>dris:fileFormat</code></a> property, to specify the form of serialization. If absent, the default value is <a href="#formats:TriG"><code>formats:TriG</code></a>.</p>
			
			<div class="marker" id="ex-rdf-output">
				<pre class="example" title="An RDF output declaration and its use by a triples map."><code>
<#MainOutput> 
   a dr:RDFOutput ;
   dr:outputName "MAIN" ;
   dris:fileFormat formats:N-Quads .

<#MainMapping>  
   ...   

   dr:triplesMap [  
      dr:logicalOutput <#MainOutput> ;
      ...
   ] .
				</code></pre>
			</div>
		</section>
		
		<section id="plain-text-output">
			<h3>Plain Text Outputs</h3>
		
			<p>A <dfn id="dfn-plain-text-output">plain text output</dfn> represents generic textual content produced by a <a href="dfn-text-lines">text lines map</a>. It is an instance of <a href="#dr:PlainTextOutput"><code>dr:PlainTextOutput</code></a>.</p>
			
			<div class="marker" id="ex-plain-text-output">
				<pre class="example" title="A plain text output declaration and its use by a text lines map."><code>
<#SPARQLOutput> 
   a dr:PlainTextOutput ;
   dr:outputName "SPARQL" .

<#MainMapping>  
   ...   

   dr:textLinesMap [  
      dr:logicalOutput <#SPARQLOutput> ;
      ...
   ] .
				</code></pre>
			</div>
		</section>
		
	</section>

		
	<section id="d2rml-document">
		<h2>D2RML Document</h2>
		
		<p>A <dfn id="dfn-d2rml-document">D2RML document</dfn> element represents a set of instructions to the <a href="#dfn-d2rml-processor">D2RML processor</a> about the way it should process the current D2RML document. The instructions are provided by including in the D2RML document an instance of <a href="#dr:D2RMLDocument"><code>dr:D2RMLDocument</code></a>, and each D2RML document may include at most one such instance.
		
		<a href="#dr:D2RMLDocument"><code>dr:D2RMLDocument</code></a> provides the <a href="#dr:logicalDatasets"><code>dr:logicalDatasets</code></a> property which informs the <a href="#dfn-d2rml-processor">D2RML processor</a> about the order by which it should process the <a href="#dfn-logical-dataset">logical datasets</a> included in the D2RML document. This is useful when the D2RML document contains more than one logical datasets and the order by which they are processed is important, e.g. when one logical dataset uses a <a href="#dfn-logical-input">logical input</a> obtained from an <a href="#dfn-information-source">information source</a> that is the <a href="#dfn-logical-output">logical output</a> of another logical dataset. The value of <a href="#dr:logicalDatasets"><code>dr:logicalDatasets</code></a> should be an <a href="https://www.w3.org/TR/rdf-schema/#ch_list"><code>rdf:List</code></a>.
		
		<figure id="fig-d2rml-configuration"><img src="d2rml-configuration.png" alt="D2RML configuration">
			<figcaption><span class="fig-title">D2RML configuration class.</span></figcaption> 
		</figure>
		
		<p>If a D2RML document does not contain a <a href="#dfn-d2rml-document">D2RML document</a> element, the <a href="#dfn-d2rml-processor">D2RML processor</a> will process all the included logical datasets in an arbitrary order. If it contains one, the <a href="#dfn-d2rml-processor">D2RML processor</a> will process only the logical datasets listed in the <a href="#dr:logicalDatasets"><code>dr:logicalDatasets</code></a>, in the specified order.</p>
		<div class="marker">
			<pre class="example" title="A D2RML logical configuration."><code>		
<#Document>
   a dr:D2RMLDocument ;
   dr:logicalDatasets ( <#AuxiliaryMapping> <#MainMapping> ) .
			</code></pre>				
		</div>		
		
		<p>The D2RML document element, should also declare any <a href="#dfn-external-parameter">external parameters</a>, using the <a href="#dr:parameter"><code>dr:parameter</code></a> property.</p>
	</section> 	


	<section id="sec-d2rml-processor">
		<h2>D2RML Processor</h2>
		
		<p>A <dfn id="dfn-d2rml-processor">D2RML processor</dfn> is a software package that can parse and execute a D2RML document.
	</section>

	<section id="d2rml-vocabulary">
		<h2>D2RML Vocabulary</h2>
		
		<section id="sec-classes">
			<h2>Classes</h2>
			<p>This section defines the classes of this vocabulary.</p>
			
			<section id="rr:BaseTableOrView">
				<h3>rr:BaseTableOrView</h3>
			</section>
			
			<section id="dr:Condition">
				<h3>dr:Condition</h3>
			</section>
			
			<section id="dr:CSVTable">
				<h3>dr:CSVTable</h3>
				<p>A logical table derived from a CSV or similarly formatted file.</p>
			</section>
			
			<section id="dr:D2RMLDocument">
				<h3>dr:D2RMLDocument</h3>
				<p>Used to determined which <a href="#dr:LogicalDataset"><code>dr:LogicalDataset</code></a>s of the current D2RML document will be executed an in which order and any external parameters.</p>
			</section>

			<section id="dr:DataParameter">
				<h3>dr:DataParameter</h3>
				<p>A parameter that obtains its value thought binding to other results.</p>
			</section>
			
			<section id="dris:DataSource">
				<h3>dris:DataSource</h3>
				<p>The abstract class of data information sources. It should be instantiated only though one of its concrete subclasses.</p>
			</section>

			<section id="dris:EnumerateRequestIterator">
				<h3>dris:EnumerateRequestIterator</h3>

				<p>A parameter that takes successively all values from a predefined list of string values.
			</section>
			
			<section id="dr:DefinedColumn">
				<h3>dr:DefinedColumn</h3>
			</section>	
			
			<section id="dr:ExternalParameter">
				<h3>dr:ExternalParameter</h3>
				<p>A parameter that is provided to the D2RML Processor by the runtime environment.</p>
				
			</section>
			
			<section id="dris:FileSource">
				<h3>dris:FileSource</h3>
				<p>Represents data obtained by accessing a file. The file may exist in the local file system or obtained from a remote source. The physical location of the file is specified by the <a href="#dris:path"><code>dris:path</code></a> property. More that one <a href="#dris:path"><code>dris:path</code></a> properties may be provided, in which case the same processing will be applied to all files. The file format may be optionally specified by the <a href="#dris:path"><code>dris:path</code></a> property, but this is needed if the file format can be detected from the file extension.</p>
			</section>
			
			<section id="dris:HTTPSource">
				<h3>dris:HTTPSource</h3>
				<p>Represents data obtained through an HTTP request. If request is a GET request the URL can be specified using the <a href="#dris:uri"><code>dris:uri</code></a> property. POST requests can be specified using the <a href="#dris:httpRequest"><code>dris:httpRequest</code></a> property with object an <a href="https://www.w3.org/TR/HTTP-in-RDF10/#RequestClass"><code>http:Request</code></a>.</p>
				
				<p>If the source returns data in pages, where a page identifier (e.g. a counter) is part of the request, that counter can be specified as a parameter using the <a href="#dr:parameter"><code>dr:parameter</code></a> property and a <a href="#dris:RequestIterator"><code>dris:RequestIterator</code></a> to iteratively assign values to it and access all source pages.</p>
			</section>
			
			<section id="dris:InformationSource">
				<h3>dris:InformationSource</h3>
				<p>The abstract class of all information sources. It should be instantiated only though one of its concrete subclasses.</p>
			</section>
			
			<section id="dr:JSONItemArray">
				<h3>dr:JSONItemArray</h3>
			</section>

			<section id="dr:LogicalData">
				<h3>dr:LogicalData</h3>
			</section>
			
			<section id="dr:LogicalDataset">
				<h3>dr:LogicalDataset</h3>
			</section>

			<section id="dr:LogicalExtension">
				<h3>dr:LogicalExtension</h3>
			</section>			

			<section id="dr:LogicalGraph">
				<h3>dr:LogicalGraph</h3>
			</section>

			<section id="dr:LogicalInput">
				<h3>dr:LogicalInput</h3>
			</section>
			
			<section id="dr:LogicalOutput">
				<h3>dr:LogicalOutput</h3>
				<p>Represents the content produced by an output map.</p>
			</section>

			<section id="dr:LogicalTable">
				<h3>dr:LogicalTable</h3>
			</section>

			<section id="dr:MappingDataset">
				<h3>dr:MappingDataset</h3>
			</section>		

			<section id="dr:OutputDataset">
				<h3>dr:OutputDataset</h3>
			</section>

			<section id="dr:Parameter">
				<h3>dr:Parameter</h3>
			</section>
			
			<section id="dr:PlainTextOutput">
				<h3>dr:PlainTextOutput</h3>
				<p>A logical output representing generic textual content.</p>
			</section>
			
			<section id="dris:RDBMS">
				<h3>dris:RDBMS</h3>
				<p>An relational database management system information source.</p>
			</section>

<!--			<section id="dris:RDFDataset">
				<h3>dris:RDFDataset</h3>
			</section> -->

			<section id="dr:RDFOutput">
				<h3>dr:RDFOutput</h3>
				<p>A logical output representing RDF content.</p>
			</section>

			<section id="dr:RegExItemArray">
				<h3>dr:RegExItemArray</h3>
			</section>

			<section id="dris:RequestIterator">
				<h3>dris:RequestIterator</h3>

				<p>A request iterator is an abstract parameter that can be used to send successive  requests to an information source. It should not be instantiated only through one of its subclasses .
			</section>		
			
			<section id="rr:RMLView">
				<h3>rr:RMLView</h3>
			</section>
			
			<section id="dris:ServiceSource">
				<h3>dris:ServiceSource</h3>
				<p>The abstract class of service information sources. It should be instantiated only though one of its concrete subclasses.</p>
			</section>

			
			<section id="dr:SetTable">
				<h3>dr:SetTable</h3>
			</section>
			
			<section id="dris:SimpleCountRequestIterator">
				<h3>dris:SimpleCountRequestIterator</h3>

				<p>A parameter that takes successively all values from an initial value up to a maximum value by the specified increment.
			</section>

			<section id="dris:SimpleKeyRequestIterator">
				<h3>dris:SimpleKeyRequestIterator</h3>

				<p>A parameter that takes successively some values. Each time the value is obtained from an element of the current data returned by the information source.</p>
			</section>
			
			<section id="dris:SPARQLEndpoint">
				<h3>dris:SPARQLEndpoint</h3>
				<p>A SPARQL endpoint information source.</p>
			</section>
			
			<section id="dr:SPARQLQueryResult">
				<h3>dr:SPARQLQueryResult</h3>
				<p>A logical table derived as a result of a SPARQL query to an RDF dataset or SPARQL Enpoint.</p>
			</section>
			
			<section id="dris:StringSource">
				<h3>dris:StringSource</h3>
				<p>Represents a in line source providing a string directly specified by the user. The string can be supplied through a parameter.</p>
			</section>		

			<section id="dr:Spreadsheet">
				<h3>dr:Spreadsheet</h3>
				<p>A logical table derived from a spreadsheet file.</p>
			</section>		
			
			<section id="dris:TransientRDFDataset">
				<h3>dris:TransientRDFDataset</h3>
			</section>

			<section id="dr:XMLItemArray">
				<h3>dr:XMLItemArray</h3>
			</section>
			
			
			
		</section>
		
		<section id="properties">
			<h2>Properties</h2>

			<p>This section defines the properties of this vocabulary.</p>

			<section id="dris:authentication">
				<h3>dris:authentication</h3>
				<p>Provides authentication information for obtaining data from an information source, if required.</p>
				<dl>
					<dt>Domain:</dt>
					<dd><a href="#dris:HTTPSource"><code>dris:HTTPSource</code></a></dd>
					<dt>Range:</dt>
					<dd><a href="#dris:Authentication"><code>dris:Authentication</code></a></dd>
				</dl>
			</section>	
			
			<section id="dr:booleanOperator">
				<h3>dr:booleanOperator</h3>
			</section>	
			
			<section id="dr:cases">
				<h3>dr:cases</h3>
			</section>	
			
			<section id="rr:class">
				<h3>rr:class</h3>
			</section>	
			
			<section id="dris:characterEncoding">
				<h3>dris:characterEncoding</h3>
				<p>The character encoding of the data obtained from a generic source, if they are textual data.</p>
				
				<dl>
					<dt>Domain:</dt>
					<dd><a href="#dris:DataSource"><code>dris:DataSource</code></a></dd>
					<dt>Range:</dt>
					<dd>An IRI specifying an encoding in the <code>formats:</code> namespace.</dd>
				</dl>
			</section>
			
			<section id="rr:column">
				<h3>rr:column</h3>
			</section>
			
			<section id="dr:columnFormulation">
				<h3>dr:columnFormulation</h3>
			</section>			

			<section id="dr:columnName">
				<h3>dr:columnName</h3>
			</section>	
			
			<section id="dr:commentMarker">
				<h3>dr:commentCharacter</h3>
				<p>A character marking the start of a line comment.</p>
				<dl>
					<dt>Domain:</dt>
					<dd><a href="#dr:CSVTable"><code>dr:CSVTable</code></a></dd>
					<dt>Range:</dt>
					<dd><a href="https://www.w3.org/TR/xmlschema11-2/#string"><code>xsd:string</code></a></dd>
				</dl>
			</section>	
			
			<section id="dr:condition">
				<h3>dr:condition</h3>
			</section>	

			<section id="rr:constant">
				<h3>rr:constant</h3>
			</section>

			<section id="dr:constantList">
				<h3>dr:constantList</h3>
			</section>

			<section id="dris:containerSource">
				<h3>dris:containerSource</h3>
				<p>The source generic source from which a secondary information source is derived. This applies to file sources extracted from compressed files (e.g. fromn .zip files) or for RDF model sources obtained from textual data. In the first case, the source generic source is the source providing the compressed file, and in the second the source providing the textual data</p>
				<dl>
					<dt>Domain:</dt>
					<dd><a href="#dris:FileSource"><code>dris:FileSource</code></a>, <a href="#dris:FileSource"><code>dris:ModelSource</code></a></dd>
					<dt>Range:</dt>
					<dd><a href="#dris:DataSource"><code>dris:DataSource</code></a></dd>
				</dl>
			</section>
			
			<section id="dris:credentials">
				<h3>dris:credentials</h3>
			</section>

			<section id="dris:databaseName">
				<h3>dris:databaseName</h3>
				<p>The database name of an RDBMS that SQL queries will be addressed to.</p>
				<dl>
					<dt>Domain:</dt>
					<dd><a href="#dris:RDBMS"><code>dris:RDBMS</code></a></dd>
					<dt>Range:</dt>
					<dd><a href="https://www.w3.org/TR/xmlschema11-2/#string"><code>xsd:string</code></a></dd>
				</dl>
			</section>

			<section id="dr:defaultGraph">
				<h3>dr:defaultGraph</h3>
				<p>A IRI representing a named graph to be used as a default graph in an RDF dataset.</p>
				<dl>
					<dt>Domain:</dt>
					<dd><a href="#dr:SPARQLQueryResult"><code>dr:SPARQLQueryResult</code></a></dd>
					<dt>Range:</dt>
					<dd>IRI</dd>
				</dl>
			</section>

			<section id="rr:datatype">
				<h3>rr:datatype</h3>
			</section>	

			<section id="dr:definedColumn">
				<h3>dr:definedColumn</h3>
			</section>	
			
			<section id="dr:definedColumns">
				<h3>dr:definedColumns</h3>
			</section>	
			
			<section id="dr:delimiter">
				<h3>dr:delimiter</h3>
				<p>A character delimiting values.</p>
				<dl>
					<dt>Domain:</dt>
					<dd><a href="#dr:CSVTable"><code>dr:CSVTable</code></a></dd>
					<dt>Range:</dt>
					<dd><a href="https://www.w3.org/TR/xmlschema11-2/#string"><code>xsd:string</code></a></dd>
				</dl>
			</section>	
			
			<section id="dr:escapeCharacter">
				<h3>dr:escapeCharacter</h3>
				<p>A character used as escape character.</p>
				<dl>
					<dt>Domain:</dt>
					<dd><a href="#dr:SPARQLQueryResult"><code>dr:SPARQLQueryResult</code></a></dd>
					<dt>Range:</dt>
					<dd>IRI</dd>
				</dl>
			</section>

			<section id="dr:exclusiveCases">
				<h3>dr:exclusiveCases</h3>
			</section>	

			<section id="dris:fileFormat">
				<h3>dris:fileFormat</h3>
				<p>The format of the data obtained from a generic source, if they are a file.</p>
				<dl>
					<dt>Domain:</dt>
					<dd><a href="#dris:DataSource"><code>dris:DataSource</code></a></dd>
					<dt>Range:</dt>
					<dd><a href="#dris:FileFormat"><code>dris:FileFormat</code></a></dd>
				</dl>
			</section>
			
			<section id="dr:function">
				<h3>dr:function</h3>
			</section>	
			
			<section id="rr:graph">
				<h3>rr:graph</h3>
			</section>

			<section id="rr:graphMap">
				<h3>rr:graphMap</h3>
			</section>
			
			<section id="dr:headerRecord">
				<h3>dr:headerRecord</h3>
				<p>Determines whether a table has a header record in the first line.</p>
				<dl>
					<dt>Domain:</dt>
					<dd><a href="#dr:CSVTable"><code>dr:CSVTable</code></a></dd>
					<dt>Range:</dt>
					<dd><a href="https://www.w3.org/TR/xmlschema11-2/#string"><code>xsd:boolean</code></a></dd>
				</dl>
			</section>
			
			<section id="dris:httpRequest">
				<h3>dris:httpRequest</h3>
				<p>The full request to specify an HTTP source.</p>
				<dl>
					<dt>Domain:</dt>
					<dd><a href="#dris:HTTPSource"><code>dris:HTTPSource</code></a></dd>
					<dt>Range:</dt>
					<dd><a href="https://www.w3.org/TR/HTTP-in-RDF10/#RequestClass"><code>http:Request</code></a></dd>
				</dl>
			</section>	
			
			<section id="dris:inContainerPath">
				<h3>dris:inContainerPath</h3>
			</section>
			
			<section id="dr:inversePredicateObjectMap">
				<h3>dr:inversePredicateObjectMap</h3>
			</section>
			
			<section id="dr:iterator">
				<h3>dr:iterator</h3>
			</section>

			<section id="dr:iteratorFormulation">
				<h3>dr:iteratorFormulation</h3>
			</section>
			
			<section id="dr:joinString">
				<h3>dr:joinString</h3>
			</section>
			
			<section id="rr:language">
				<h3>rr:language</h3>
			</section>	

			<section id="dr:languageMap">
				<h3>dr:languageMap</h3>
			</section>	

			<section id="dr:limit">
				<h3>dr:limit</h3>
			</section>	
			
			<section id="dr:locally">
				<h3>dr:locally</h3>
			</section>
			
			<section id="dr:localTransformation">
				<h3>dr:localTransformation</h3>
			</section>			

			<section id="dr:logicalArray">
				<h3>dr:logicalArray</h3>
			</section>	

			<section id="dr:logicalData">
				<h3>dr:logicalData</h3>
			</section>

			<section id="dr:logicalDatasets">
				<h3>dr:logicalDatasets</h3>
				<p>An ordered list of triples maps.</p>
				<dl>
					<dt>Domain:</dt>
					<dd><a href="#dr:D2RMLDocument"><code>dr:D2RMLDocument</code></a></dd>
					<dt>Range:</dt>
					<dd>A <a href="https://www.w3.org/TR/rdf-schema/#ch_list"><code>rdf:List</code></a> of <a href="https://www.w3.org/TR/xmlschema11-2/#string"><code>dr:TriplesMap</code></a>s</dd>
				</dl>
			</section>
			
			<section id="dr:logicalGraph">
				<h3>dr:logicalGraph</h3>
			</section>			
			
			<section id="dr:logicalOutput">
				<h3>dr:logicalOutput</h3>
			</section>	

			<section id="dr:logicalOutputMap">
				<h3>dr:logicalOutputMap</h3>
			</section>	

			<section id="dr:logicalTable">
				<h3>dr:logicalTable</h3>
			</section>
			
			<section id="dr:name">
				<h3>dr:name</h3>
			</section>	

			<section id="dr:namedGraph">
				<h3>dr:namedGraph</h3>
				<p>A IRI representing a named graph in an RDF dataset.</p>
				<dl>
					<dt>Domain:</dt>
					<dd><a href="#dr:SPARQLQueryResult"><code>dr:SPARQLQueryResult</code></a>, <a href="#dr:LogicalGraph"><code>dr:LogicalGraph</code></a></dd>
					<dt>Range:</dt>
					<dd>IRI</dd>
				</dl>
			</section>

			<section id="rr:object">
				<h3>rr:object</h3>
			</section>

			<section id="rr:objectMap">
				<h3>rr:objectMap</h3>
			</section>
			
			<section id="dr:offset">
				<h3>dr:offset</h3>
			</section>			

			<section id="dr:operand">
				<h3>dr:operand</h3>
			</section>	
			
			<section id="dr:outputName">
				<h3>dr:outputName</h3>
			</section>

			<section id="dris:password">
				<h3>dris:password</h3>
				<p>A password needed to access an information source through an authentication process, or a passowrd needed to decrypt the data obtained from a data source, if they are password protected.</p>
				<dl>
					<dt>Domain:</dt>
					<dd><a href="#dris:DataSource"><code>dris:DataSource</code></a>, <a href="#dris:RDBMS"><code>dris:RDBMS</code></a></dd>
					<dt>Range:</dt>
					<dd><a href="https://www.w3.org/TR/xmlschema11-2/#string"><code>xsd:string</code></a></dd>
				</dl>
			</section>

			<section id="dr:parameter">
				<h3>dr:parameter</h3>
				<p>A parameter of an information source that does not obtain directly its values, but through the mechanism specified in the parameter specification.</p>
				<dl>
					<dt>Domain:</dt>
					<dd><a href="#dris:InformationSource"><code>dris:InformationSource</code></a></dd>
					<dt>Range:</dt>
					<dd><a href="#dr:Parameter"><code>dr:Parameter</code></a></dd>
				</dl>
			</section>		

			<section id="dr:parameterBinding">
				<h3>dr:parameterBinding</h3>
			</section>

			<section id="dr:parameterName">
				<h3>dr:parameterName</h3>
				<p>The name of parameter.</p>
				<dl>
					<dt>Domain:</dt>
					<dd><a href="#dr:Parameter"><code>dr:Parameter</code></a></dd>
					<dt>Range:</dt>
					<dd><a href="https://www.w3.org/TR/xmlschema11-2/#string"><code>xsd:string</code></a></dd>
				</dl>
			</section>	

<!--			<section id="dr:parameters">
				<h3>dr:parameters</h3>
				<p>To be used instead of multiple <a href="#dr:parameter"><code>dr:parameter</code></a> properties when order is important.</p>
				<dl>
					<dt>Domain:</dt>
					<dd><a href="#dris:InformationSource"><code>dris:InformationSource</code></a></dd>
					<dt>Range:</dt>
					<dd>A <a href="https://www.w3.org/TR/rdf-schema/#ch_list"><code>rdf:List</code></a> of <a href="#dr:Parameter"><code>dr:Parameter</code></a>s</dd>
				</dl>
			</section>		-->
			
			<section id="dris:path">
				<h3>dris:path</h3>
				<p>The path to a file in a file system or within a file container (e.g. in zipped files.) Paths should be absolute. The preferred separator for any file system is /.</p>
				<dl>
					<dt>Domain:</dt>
					<dd><a href="#dris:FileSource"><code>dris:FileSource</code></a></dd>
					<dt>Range:</dt>
					<dd><a href="https://www.w3.org/TR/xmlschema11-2/#string"><code>xsd:string</code></a></dd>
				</dl>
			</section>
			
			<section id="dris:paths">
				<h3>dris:paths</h3>
				<p>To be used instead of multiple <a href="#dris:path"><code>dris:path</code></a> properties when order is important.</p>
				<dl>
					<dt>Domain:</dt>
					<dd><a href="#dris:FileSource"><code>dris:FileSource</code></a></dd>
					<dt>Range:</dt>
					<dd>A <a href="https://www.w3.org/TR/rdf-schema/#ch_list"><code>rdf:List</code></a> of <a href="https://www.w3.org/TR/xmlschema11-2/#string"><code>xsd:string</code></a>s</dd>
				</dl>
			</section>		
			
			<section id="dr:pivot">
				<h3>dr:pivot</h3>
			</section>		
			
			<section id="dr:pivots">
				<h3>dr:pivots</h3>
			</section>
			
			<section id="rr:predicate">
				<h3>rr:predicate</h3>
			</section>

			<section id="rr:predicateMap">
				<h3>rr:predicateMap</h3>
			</section>
			
			<section id="rr:predicateObjectMap">
				<h3>rr:predicateObjectMap</h3>
			</section>
			
			<section id="dris:preprocessingFunction">
				<h3>dris:preprocessFunction</h3>
				<p>Specifies a function that will be applied on the raw data of a DataSource.</p>
				<dl>
					<dt>Domain:</dt>
					<dd><a href="#dris:DataSource"><code>dris:DataSource</code></a></dd>
					<dt>Range:</dt>
					<dd><a href="#drop:Function"><code>drop:Function</code></a></dd>
				</dl>
			</section>
			
			<section id="dris:preprocessingFunctions">
				<h3>dris:preprocessFunctions</h3>
				<p>To be used instead of multiple <a href="#dris:preprocessingFunction"><code>dris:preprocessingFunction</code></a> properties when order is important</p>
				<dl>
					<dt>Domain:</dt>
					<dd><a href="#dris:DataSource"><code>dris:DataSource</code></a></dd>
					<dt>Range:</dt>
					<dd>A <a href="https://www.w3.org/TR/rdf-schema/#ch_list"><code>rdf:List</code></a> of <a href="#drop:Function"><code>drop:Function</code></a>s</dd>
				</dl>
			</section>
			
			<section id="dr:quoteCharacter">
				<h3>dr:quoteCharacter</h3>
				<p>A character used to encapsulate values containing special characters.</p>
				<dl>
					<dt>Domain:</dt>
					<dd><a href="#dr:CSVTable"><code>dr:CSVTable</code></a></dd>
					<dt>Range:</dt>
					<dd><a href="https://www.w3.org/TR/xmlschema11-2/#string"><code>xsd:string</code></a></dd>
				</dl>
			</section>	
			
			<section id="dr:rdfFormat">
				<h3>dr:rdfFormat</h3>
			</section>			

			<section id="dris:rdbmsType">
				<h3>dris:rdbmsType</h3>
				<p>The type of an RDBMS information source.</p>
				<dl>
					<dt>Domain:</dt>
					<dd><a href="#dris:RDBMS"><code>dris:RDBMS</code></a></dd>
					<dt>Range:</dt>
					<dd>A IRI representing an RDBMS type. A list of currently supported RDBMS types is provided <a href="#tab-rdbms-types"><code>here</code></a></dd>
				</dl>
			</section>	

			<section id="dr:rdfMap">
				<h3>dr:rdfMap</h3>
			</section>	

			<section id="dr:recordSeparator">
				<h3>dr:recordSeparator</h3>
				<p>A character used as record separator.</p>
				<dl>
					<dt>Domain:</dt>
					<dd><a href="#dr:CSVTable"><code>dr:CSVTable</code></a></dd>
					<dt>Range:</dt>
					<dd><a href="https://www.w3.org/TR/xmlschema11-2/#string"><code>xsd:string</code></a></dd>
				</dl>
			</section>			
			
			<section id="dr:sheetName">
				<h3>dr:sheetName</h3>
				<p>The sheet name of a spreadsheet.</p>
				<dl>
					<dt>Domain:</dt>
					<dd><a href="#dr:Spreadsheet"><code>dr:Spreadsheet</code></a></dd>
					<dt>Range:</dt>
					<dd><a href="https://www.w3.org/TR/xmlschema11-2/#string"><code>xsd:string</code></a></dd>
				</dl>
			</section>
			
			<section id="dr:source">
				<h3>dr:source</h3>
			</section>
			
			<section id="dr:sources">
				<h3>dr:sources</h3>
			</section>

			<section id="dr:sparqlConstructQuery">
				<h3>dr:sparqlConstructQuery</h3>
				<p>A Valid SPARQL CONSTRUCT query.</p>
				<dl>
					<dt>Domain:</dt>
					<dd><a href="#dr:LogicalGraph"><code>dr:LogicalGraph</code></a></dd>
					<dt>Range:</dt>
					<dd><a href="https://www.w3.org/TR/xmlschema11-2/#string"><code>xsd:string</code></a></dd>
				</dl>
			</section>

			<section id="dr:sparqlSelectQuery">
				<h3>dr:sparqlSelectQuery</h3>
				<p>A Valid SPARQL SELECT query.</p>
				<dl>
					<dt>Domain:</dt>
					<dd><a href="#dr:SPARQLQueryResult"><code>dr:SPARQLQueryResult</code></a></dd>
					<dt>Range:</dt>
					<dd><a href="https://www.w3.org/TR/xmlschema11-2/#string"><code>xsd:string</code></a></dd>
				</dl>
			</section>

			<section id="dr:sparqlUpdateQueries">
				<h3>dr:sparqlUpdateQueries</h3>
			</section>
			
			<section id="dr:sparqlUpdateQuery">
				<h3>dr:sparqlUpdateQuery</h3>
				<p>A Valid SPARQL Update query.</p>
				<dl>
					<dt>Domain:</dt>
					<dd><a href="#dr:LogicalGraph"><code>dr:LogicalGraph</code></a></dd>
					<dt>Range:</dt>
					<dd><a href="https://www.w3.org/TR/xmlschema11-2/#string"><code>xsd:string</code></a></dd>
				</dl>
			</section>

			<section id="dr:sparqlUpdateVersion">
				<h3>dr:sparqlUpdateVersion</h3>
				<p>An identifier for a SPARQL Update version.</p>
				<dl>
					<dt>Domain:</dt>
					<dd><a href="#dr:LogicalGraph"><code>dr:LogicalGraph</code></a></dd>
					<dt>Range:</dt>
					<dd>IRI</dd>
				</dl>
			</section>

			<section id="dr:sparqlVersion">
				<h3>dr:sparqlVersion</h3>
			</section>

			<section id="dris:string">
				<h3>dris:string</h3>
				<p>The content of a string source.</p>
				<dl>
					<dt>Domain:</dt>
					<dd><a href="#dris:StringSource"><code>dris:StringSource</code></a></dd>
					<dt>Range:</dt>
					<dd><a href="https://www.w3.org/TR/xmlschema11-2/#string"><code>xsd:string</code></a></dd>
				</dl>
			</section>				
			
			<section id="rr:subjectMap">
				<h3>rr:subjectMap</h3>
			</section>

			<section id="rr:template">
				<h3>rr:template</h3>
			</section>

			<section id="rr:termType">
				<h3>rr:termType</h3>
			</section>

			<section id="dr:textLinesMap">
				<h3>dr:textLinesMap</h3>
			</section>	

			<section id="dr:transferedColumns">
				<h3>dr:transferedColumns</h3>
			</section>			

			<section id="dr:transformation">
				<h3>dr:transformation</h3>
			</section>
			
			<section id="dr:transformations">
				<h3>dr:transformations</h3>
			</section>

			<section id="dr:triplesMap">
				<h3>dr:triplesMap</h3>
			</section>	
			
			<section id="dris:uri">
				<h3>dris:uri</h3>
				<p>The uri for a HTTP source specified by a simple GET request or for a SPARQL Endpoint.</p>
				<dl>
					<dt>Domain:</dt>
					<dd><a href="#dris:HTTPSource"><code>dris:HTTPSource</code></a>, <a href="#dris:SPARQLEndpoint"><code>dris:SPARQLEndpoint</code></a></dd>
					<dt>Range:</dt>
					<dd><a href="https://www.w3.org/TR/xmlschema11-2/#string"><code>xsd:string</code></a></dd>
				</dl>
			</section>		
			
			<section id="dris:values">
				<h3>dris:values</h3>
			</section>				
				

		</section>

		<section id="individuals">
			<h2>Individuals</h2>
			
			<section id="dris:CurrentD2RMLDocument">
				<h3>Current D2RML Document</h3>
				
				<p><div id="dris:CurrentD2RMLDocument"><code>dris:CurrentD2RMLDocument</code></a> represents the current D2RML document as an <a href="http://www.w3.org/TR/2008/REC-rdf-sparql-query-20080115/#rdfDataset">RDF dataset</a>. It can be used as the value of the <a href="#dr:source"><code>dr:source</code></a> of a <a href="#dr:LogicalGraph"><code>dr:LogicalGraph</code></a>.</p>
				
				<div class="marker">
					<pre class="example" title="Use of dris:CurrentD2RMLDocument."><code>
<#RDFDataset>  
   dr:logicalGraph [ 
      dr:source dris:CurrentD2RMLDocument ;
      dr:namedGraph <#DataTriples> ;
   ] .
   
<#DataTriples> {
   ex:101 rdfs:label "Company 101" .
   ex:102 rdfs:label "Company 102" .
}   
					</code></pre>
				</div>		
				
			</section>

			
			<section id="term-types">
				<h3>Term Types</h3>
				
				<p>The IRIs that represent <a href="#dfn-term-type">term types</a> and can be the values of the <a href="#rr:termType"><code>rr:termType</code></a> property. They are defined in [[R2RML]].</p>
				
				<table class="def" id="tab-term-types" rules="all">
					<caption>Table 2: Term types.</caption>
					<thead>
						<tr>
							<th><strong>URI</strong></th>
							<th><strong>Description</strong></th>
						</tr>
					</thead>				
					<tbody>
						<tr>
							<td><div id="rr:BlankNode"><code>rr:BlankNode</code></div></td>
							<td>A <dfn id="dfn-blank-node"><a href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-blank-node">blank node</a></dfn></td>
						</tr>
						<tr>
							<td><div id="rr:IRI"><code>rr:IRI</code></div></td>
							<td>An <dfn id="dfn-iri"><a href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-URI-reference">IRI</dfn></td>
						</tr>
						<tr>
							<td><div id="rr:Literal"><code>rr:Literal</code></div></td>
							<td>A <dfn id="dfn-literal"><a href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-literal">literal</dfn></td>
						</tr>
					</tbody>
				</table>
			</section>
			

			<section id="rdbms-types">
				<h3>RDBMS Types</h3>
				
				<p>The IRIs that represent <a href="#dfn-rdbms-type">RDBMS types</a> and can be the values of the <a href="#dris:rdbmsType"><code>dris:rdbmsType</code></a> property.</p>
				
				<p>The support of RDBMS's depends on the <a href="#dfn-d2rml-processor">D2RML processor</a>, and a D2RML processor implementation may provide support for additional RDBMS's.</p>

				<table class="def" id="tab-rdbms-types" rules="all">
					<caption>Table 2: RDBMS types.</caption>
					<thead>
						<tr>
							<th><strong>IRI</strong></th>
							<th><strong>Description</strong></th>
						</tr>
					</thead>				
					<tbody>
						<tr>
							<td><div id="dris:MicrosoftAccess"><code>dris:MicrosoftAccess</code></div></td>
							<td>A Microsoft Access database</td>
						</tr>
						<tr>
							<td><div id="dris:MySQL"><code>dris:MySQL</code></div></td>
							<td>A MySQL database</td>
						</tr>
						<tr>
							<td><div id="dris:PostgreSQL"><code>dris:PostgreSQL</code></div></td>
							<td>A PostgreSQL database</td>
						</tr>
					</tbody>
				</table>
			</section>
			
			<section>
				<h3>Formulation Languages</h3>

				<p>The IRIs that can be the values of the <a href="#dr:iteratorFormulation"><code>dr:iteratorFormulation</code></a> and <a href="#dr:columnFormulation"><code>dr:columnFormulation</code></a> property.</p>

				<p>A The support of regular expression syntax language depends on the <a href="#dfn-d2rml-processor">D2RML processor</a>, and a D2RML processor implementation may provide support for additional syntaxes.</p>

				<table class="def" id="tab-formulation-languages" rules="all">
					<caption>Table 3: Formulation languages.</caption>
					<thead>
						<tr>
							<th><strong>IRI</strong></th>
							<th><strong>Description</strong></th>
						</tr>
					</thead>				
					<tbody>
						<tr>
							<td><div id="dris:JSONPath"><code>dris:JSONPath</code></div></td>
							<td>A JSONPath expression</td>
						</tr>
						<tr>
							<td><div id="dris:JSONElement"><code>dris:JSONElement</code></div></td>
							<td>A JSON field name</td>
						</tr>						
						<tr>
							<td><div id="dris:JavaRegEx"><code>dris:JavaRegEx</code></div></td>
							<td>A regular expression in Java syntax containing at least one capturing group</td>
						</tr>
						<tr>
							<td><div id="dris:PythonRegEx"><code>dris:PerlRegEx</code></div></td>
							<td>A regular expression in Perl syntax containing at least one capturing group</td>
						</tr>						<tr>
							<td><div id="dris:PythonRegEx"><code>dris:PythonRegEx</code></div></td>
							<td>A regular expression in Python syntax containing at least one capturing group</td>
						</tr>
						<tr>
							<td><div id="dris:XMLElement"><code>dris:XMLElement</code></div></td>
							<td>An XML element name</td>
						</tr>
						<tr>
							<td><div id="dris:XPath"><code>dris:XPath</code></div></td>
							<td>An XPath expression</td>
						</tr>
					</tbody>
				</table>
			</section>

			<section id="defined-column-functions">
				<h3>Functions</h3>
				
				<p>The <a href="#dfn-d2rml-processor">D2RML processor</a> may provide support for several <a href="#dfn-function">functions</a>. Each function is identified by a IRI that can be the value of the <a href="#dr:function"><code>dr:function</code></a> in a <a href="#dfn-defined-column">defined column</a>.</p>
				
				<p>Each function takes zero or more arguments, characterized by a name, and for a single input should return either a single or multiple column result.</p>
				
				<p>Below are listed functions in the <code>drop:</code> namespace.</p>

				<table class="def" id="tab-functions" rules="all">
					<caption>Table 3: Functions.</caption>
					<thead>
						<tr>
							<th><strong>URI</strong></th>
							<th><strong>Arguments</strong></th>
							<th><strong>Result Columns</strong></th>
							<th><strong>Description</strong></th>
						</tr>
					</thead>				
					<tbody>
						<tr>
							<td><div id="drop:capitalize"><code>drop:capitalize</code></div></td>
							<td>input</td>
							<td>result</td>
							<td>Capitalizes <i>input</i> and returns the result.</td>
						</tr>					
						<tr>
							<td><div id="drop:capitalizeFully"><code>drop:capitalizeFully</code></div></td>
							<td>input</td>
							<td>result</td>
							<td>Capitalizes fully <i>input</i> and returns the result.</td>
						</tr>					
						<tr>
							<td><div id="drop:currentTime"><code>drop:currentTime</code></div></td>
							<td></td>
							<td>result</td>
							<td>Returns the current system time.</td>
						</tr>
						<tr>
							<td><div id="drop:extractMatch"><code>drop:extractMatch</code></div></td>
							<td>input, regex</td>
							<td>index, match#1, match#2, ...</td>
							<td>Finds matches of <i>regex</i> in <i>input</i> returns the matched capturing groups.</td>
						</tr>					
						<tr>
							<td><div id="drop:identity"><code>drop:identity</code></div></td>
							<td>input</td>
							<td>result</td>
							<td>Returns <i>input</i>.</td>
						</tr>					
<!--						<tr>
							<td><div id="drop:lowercase"><code>drop:lowercase</code></div></td>
							<td>input</td>
							<td>result</td>
							<td>Converts <i>input</i> to lowercase and returns it.</td>
						</tr>-->
						<tr>
							<td><div id="drop:mathExpressionEvaluate"><code>drop:mathExpressionEvaluate</code></div></td>
							<td>expression, var1, var2, ..., datatype</td>
							<td>result</td>
							<td></td>
						</tr>					
						<tr>
							<td><div id="drop:order"><code>drop:order</code></div></td>
							<td></td>
							<td>result</td>
							<td></td>
						</tr>
<!--						<tr>
							<td><div id="drop:replace"><code>drop:replace</code></div></td>
							<td>input, regex, replacement</td>
							<td>result</td>
							<td>Replaces <i>regex</i> in <i>input</i> by <i>replacement</i> and returns the result.</td>
						</tr>-->
<!--						<tr>
							<td><div id="drop:round"><code>drop:round</code></div></td>
							<td>input, digits</td>
							<td>result</td>
							<td>Rounds <i>input</i> to <i>digits</i> decimal digits and returns it.</td>
						</tr> -->
<!--						<tr>
							<td><div id="drop:strlength"><code>drop:strlength</code></div></td>
							<td>input</td>
							<td>result</td>
							<td>Returns the length of <i>input</i>.</td>
						</tr>-->					
<!--						<tr>
							<td><div id="drop:substring"><code>drop:substring</code></div></td>
							<td>input, beginIndex, endIndex</td>
							<td>result</td>
							<td>Return the substring of <i>input</i> starting at <i>beginIndex</i> and ending at <i>endIndex</i>.</td>
						</tr>-->
<!--						<tr>
							<td><div id="drop:split"><code>drop:split</code></div></td>
							<td>input, separator</td>
							<td>result</td>
							<td>Splits <i>input</i> by <i>separator</i> and returns a value set with the split parts.</td>
						</tr> -->
						<tr>
							<td><div id="drop:trim"><code>drop:trim</code></div></td>
							<td>input</td>
							<td>result</td>
							<td>Trims white space at the beginning and end of <i>input</i> and returns the result.</td>
						</tr>
<!--						<tr>
							<td><div id="drop:uppercase"><code>drop:uppercase</code></div></td>
							<td>input</td>
							<td>result</td>
							<td>Converts <i>input</i> to uppercase and returns it.</td>
						</tr>-->
						<tr>
							<td><div id="drop:urldecode"><code>drop:urldecode</code></div></td>
							<td>input</td>
							<td>result</td>
							<td>URL decodes <i>input</i> and returns it.</td>
						</tr>					
<!--						<tr>
							<td><div id="drop:urlencode"><code>drop:urlencode</code></div></td>
							<td>input</td>
							<td>result</td>
							<td>URL encodes <i>input</i> and returns it.</td>
						</tr>-->					
						<tr>
							<td><div id="drop:uuid"><code>drop:uuid</code></div></td>
							<td></td>
							<td>result</td>
							<td>Returns a universally unique identifier.</td>
						</tr>
					</tbody>
				</table>
			</section>
			
		</section>
	</section>

	<section id="sec-extensive-example">
		<h2>An extensive example</h2>

		<p>This section presents a detail, real example of using D2RML to convert data to RDF triples. The example transforms data from the <a href="https://data.brreg.no/enhetsregisteret/oppslag/enheter">legal entities open dataset</a> provided by <a href="https://www.brreg.no/en/">Brnnysund Register Centre</a> (the Norwegian business register) to an RDF dataset according to the <a href="https://stirdata.github.io/data-specification/">STIRData business data model</a>.</p>
		
		<p>Below the entire D2RML document that does the transfomration will be list, split in parts, to provide useful explanation.</p>

		<section>
			<h3>Namespaces</h3>
		
			<p>The document starts with the definition of the necessary namespaces.</p>
		
			<div class="marker" id="ex-detailed-example-namespaces">
				<pre class="example" title="Conversion of business register data to RDF dataset: Namespaces.">
# General namespaces
@prefix adms: &lt;http://www.w3.org/ns/adms#&gt; .
@prefix dbo: &lt;https://dbpedia.org/ontology/&gt; .
@prefix dcterms: &lt;http://purl.org/dc/terms/&gt; .
@prefix locn: &lt;http://www.w3.org/ns/locn#&gt; .
@prefix schema: &lt;https://schema.org/&gt; .
@prefix skos: &lt;http://www.w3.org/2004/02/skos/core#&gt; .
@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .
@prefix owl: &lt;http://www.w3.org/2002/07/owl#&gt; .
@prefix legal: &lt;http://www.w3.org/ns/legal#&gt; .

# D2RML namespaces
@prefix rr: &lt;http://www.w3.org/ns/r2rml#&gt; .
@prefix dr: &lt;http://islab.ntua.gr/ns/d2rml#&gt; .
@prefix drop: &lt;http://islab.ntua.gr/ns/d2rml-op#&gt; .
@prefix dris: &lt;http://islab.ntua.gr/ns/d2rml-is#&gt; .

# STIRdata namespaces
@prefix sd-model: &lt;https://lod.stirdata.eu/model/&gt; .
@prefix sd-agency-no: &lt;https://lod.stirdata.eu/data/agency/no/&gt; .
@prefix sd-organization-no: &lt;https://lod.stirdata.eu/data/organization/no/&gt; .
@prefix sd-address-no: &lt;https://lod.stirdata.eu/data/address/no/&gt; .
@prefix sd-identifier-no: &lt;https://lod.stirdata.eu/data/identifier/no/&gt; .
@prefix sd-legalform-code-no: &lt;https://lod.stirdata.eu/legalform/no/code/&gt; .
@prefix nace-code-no: &lt;https://lod.stirdata.eu/nace/sic2007-no/code/&gt; .
@prefix nuts-code: &lt;https://lod.stirdata.eu/nuts/code/&gt; .
@prefix lau-code: &lt;https://lod.stirdata.eu/lau/code/&gt; .
				</code></pre>
			</div>

		</section>
		
		<section>
			<h3>Information Sources</h3>
		
			<p>Next, the document contains the definitions of the information sources from which data will be obtained.<p>
		
			<div class="marker" id="ex-detailed-example-information-sources">
				<pre class="example" title="Conversion of business register data to RDF dataset: information sources.">
# Brnnysund Register Centre legal entities dataset
<#EnheterSource>
   a dris:HTTPSource ;
   dris:uri "https://data.brreg.no/enhetsregisteret/api/enheter/lastned" ;
   dris:inContainerPath "enheter_alle.json" .

# REST service resolving a country names to the respective ISO 3166 country code
<#CountriesSource>
   a dris:HTTPSource ;
   dris:uri "https://stirdata-semantic.ails.ece.ntua.gr/api/content/index/countries/search?text={@@TEXT@@}&fields=r2-uri,r3-lexical-form&type=match-phrase" ;
   dr:parameter [
      a dr:DataParameter ;
      dr:name "TEXT" ;
   ] .

# REST service resolving 
<#NutsSource>    
   a dris:HTTPSource ;
   dris:uri "https://stirdata-semantic.ails.ece.ntua.gr/api/content/index/nuts/search?text={@@TEXT@@}&fields=r0-lexical-form&type=match&keys=r1-lexical-form" ;
   dr:parameter [
      a dr:DataParameter ;
      dr:name "TEXT" ;
   ] .
   
# REST service resolving a post code to the respective NUTS3 code.
<#PostCodeSource>
   a dris:HTTPSource ;
   dris:uri "https://apps.islab.ntua.gr/geo/api/postcode?country-code={@@COUNTRY@@}&postcode={@@POSTCODE@@}" ;
   dr:parameter [
      a dr:DataParameter ;
      dr:name "COUNTRY" ;
   ] ;
   dr:parameter [
      a dr:DataParameter ;
      dr:name "POSTCODE" ;
   ] .
   
				</code></pre>
			</div>
	
			<p><code><#EnheterSource></code> is an <a href="#dfn-http-source">HTTP source</a> that provides the actual business register data. The data are obtained in bulk though a suitable REST API, which returns a gzip file. The returned file is named <code>enheter_alle.json.gz</code> and contains the file <code>enheter_alle.json</code>. Because the information source provides a gzip file, <code><#EnheterSource></code> is a <a href="#dfn-container-source">container source</a>, and the shortcut form using the <a href="dris:inContainerSource"><code>dris:inContainerSource</code></a> property to access the file inside the gzip file is used. No <a href="dris:fileFormat"><code>dris:fileFormat</code></a> property is provided for <code><#EnheterSource></code> because the file format can be derived from the extension of the provided file.</p>
		
			<p>The contents of <code>enheter_alle.json</code> is a JSON array, containing an object for each registered company. An extract of that JSON array, showing a single company is the following:</pt>

			<div class="marker" id="ex-detailed-example-enheter-json">
				<pre class="example" title="Conversion of business register data to RDF dataset: same business register data.">
[ ...
  {
  "organisasjonsnummer" : "994924974",
  "navn" : ".:SOR-ESPORTS",
  "organisasjonsform" : {
    "kode" : "FLI",
    "beskrivelse" : "Forening/lag/innretning",
    "links" : [ ]
  },
  "hjemmeside" : "www.soldier.no",
  "registreringsdatoEnhetsregisteret" : "2010-01-05",
  "registrertIMvaregisteret" : false,
  "naeringskode1" : {
    "beskrivelse" : "Aktiviteter i andre interesseorganisasjoner ikke nevnt annet sted",
    "kode" : "94.991"
  },
  "antallAnsatte" : 0,
  "forretningsadresse" : {
    "land" : "Norge",
    "landkode" : "NO",
    "postnummer" : "1407",
    "poststed" : "VINTERBRO",
    "adresse" : [ "c/o Bjrn-Hugo Hansen", "Svalestien 43" ],
    "kommune" : "S",
    "kommunenummer" : "3021"
  },
  "stiftelsesdato" : "2007-01-01",
  "institusjonellSektorkode" : {
    "kode" : "7000",
    "beskrivelse" : "Ideelle organisasjoner"
  },
  "registrertIForetaksregisteret" : false,
  "registrertIStiftelsesregisteret" : false,
  "registrertIFrivillighetsregisteret" : false,
  "konkurs" : false,
  "underAvvikling" : false,
  "underTvangsavviklingEllerTvangsopplosning" : false,
  "maalform" : "Bokml",
  "links" : [ ]
}, 
... ]
				</code><pre>
			</div>
			
			<p><code><#CountriesSource></code> is an <a href="#dfn-http-source">HTTP source</a>.</p>
			
			<p><code><#NutsSource></code> is an <a href="#dfn-http-source">HTTP source</a>.</p>
			
			<p><code><#PostCodeSource></code> is an <a href="#dfn-http-source">HTTP source</a> that given a country code ISO 3166 (<code>COUNTRY</code> parameter) and a valid post code (<code>POSTCODE</code> parameter) for that country, it returns the <a href="https://ec.europa.eu/eurostat/web/nuts/background">NUTS 3</a> level code and <a href="https://ec.europa.eu/eurostat/web/nuts/local-administrative-units">LAU</a> code the specific post codes belong to.</p>
			
		</section>

		<section>
			<h3>Logical Data</h3>
			
			<p>The <code><#CountriesSource></code>, <code><#NutsSource></code>, and <code><#PostCodeSource></code> sources will be used to used to assign a country code, and a NUTS3 and LAU code to a company. Since that information differs for each company, the sources will be used to provide <a href="#dfn-logical-extension">logical extension</a> to each <a href="#dfn-logical-row">logical row</a> that will be generated from contents of the <code>enheter_alle.json</code>.</p>
			
			<p>Therefore, next the D2RML document provides the necessary <a href="#dfn-logical-data">logical data</a> definitions:</p>
			
			<div class="marker" id="ex-detailed-example-logical-data">
				<pre class="example" title="Conversion of business register data to RDF dataset: logical data definitions."><code>
# Logical Data for country transformation
<#CountryLogicalData>
   dr:logicalArray [ 
      a dr:JSONItemArray ;
      dr:source <#CountriesSource> ;
      dr:iterator "$";
      dr:limit 1;
   ] .

# Logical Data for NUTS transformation   
<#NutsLogicalData>
   dr:logicalArray [ 
      a dr:JSONItemArray ;
      dr:source <#NutsSource> ;
      dr:iterator "$";
      dr:limit 1;
   ] . 

# Logical Data for post code transformation   
<#PostCodeLogicalData>
   dr:logicalArray [ 
      a dr:JSONItemArray ;
      dr:source <#PostCodeSource> ;
      dr:iterator "$";
      dr:limit 1;
   ] . 
				</code></pre>
			</div>
			
			<p>Three logical data definitions are provides, one for each information source. The definitions are identical, since all underlying <a href="#dfn-logical-array">logical array</a> are JSON arrays.</p>
		</section>
		
		<section>
			<h3>Triples Map</h3>
		
			<p>The main part of the D2RML document is the definition of the <a href="#dfn-triples-map">triples map</a> that contains the rules for generating the desired triples.</p>
			
			<section>
			<h3>Logical Input</h3>
			
			<p>It starts by specifying the relevant <a href="#dfn-logical-input">logical input</a>, which is a <a href="#dr:JSONItemArray"><code>dr:JSONItemArray</code></a> produced from the data block provided by <code><#EnheterSource></code>. The <a href="#dfn-iterator-formulation">iterator formulation</a> is <a href="#dris:JSONElement"><code>dris:JSONElement</code></a>, and no <a href="#dfn-iterator">iterator</a> is specified, because <code><#EnheterSource></code> provides JSON array and the logical rows of the <a href="#dr:JSONItemArray"><code>dr:JSONItemArray</code></a> should be its elements. <!--The <a href="#dfn-column-formulation">column formulation</a> is <code>dris:JSONPath</code>.-->
			
			<div class="marker" id="ex-detailed-example-enheter-json">
				<pre class="example" title="Conversion of business register data to RDF dataset: business register data triples map: logical array."><code>
<#EnheterMapping>  
   dr:logicalArray [ 
      a dr:JSONItemArray;
      dr:source <#EnheterSource> ;
      dr:iteratorFormulation dris:JSONElement ;
   ] ;
				</code></pre>
			</code>
			
			</section>
			
			<section>
			<h3>Transformations</h3>
			
			<p>Next, definitions of <a href="#dfn-transformation">transformations</a> are provided that use the country (<code>$.postadresse.land</code> and <code>$.forretningsadresse.land</code> logical columns) and postcode (<code>$.postadresse.postnummer</code> and <code>$.forretningsadresse.postnummer</code> logical columns) information provided as part of the address of each company. The necessary <a href="#dfn-parameter-binding">parameter bindings</a> for the logical data are provided. Note that the original data contain postal and business addresses, therefore there are two transformations for each logical data. Note also that each transformations on the <code><#NutsLogicalData></code> use the results of the respective <code><#PostCodeLogicalData></code>. The second parameter binding of the transformation on <code><#PostCodeLogicalData></code> is a <a href="#dfn-conditional-value-map">conditional value map</a> and as a result the transformation is executed only when <code>$.postadresse.postnummer</code> or <code>$.forretningsadresse.postnummer</code> are non empty.</p>
			
			<div class="marker" id="ex-detailed-example-triples-map-transformations">
				<pre class="example" title="Conversion of business register data to RDF dataset: business register data triples map: transformations."><code>   
<#EnheterMapping>  
   dr:transformation [
      dr:logicalData <#CountryLogicalData> ;
      dr:name "PostalCountryTransformation";
      dr:parameterBinding [ 
         dr:parameterName "TEXT" ;
         rr:column "$.postadresse.land" ;
      ]  ;
   ] ;
   
   dr:transformation [
      dr:logicalData <#PostCodeLogicalData> ;
      dr:name "PostalPostCodeTransformation";
      dr:parameterBinding [ 
         dr:parameterName "COUNTRY" ;
         rr:constant "NO" ;
      ] ;
      dr:parameterBinding [ 
         dr:parameterName "POSTCODE" ;
         rr:column "$.postadresse.postnummer" ;
         dr:condition [
            rr:column "$.postadresse.postnummer" ;
            drop:neq "" ;
         ] ; 		 
      ]  ;
   ] ;
   
   dr:transformation [
      dr:logicalData <#NutsLogicalData> ;
      dr:name "PostalNutsTransformation";
      dr:parameterBinding [ 
         dr:parameterName "TEXT" ;
         rr:column "PostalPostCodeTransformation~~$.NUTS3" ;
      ]  ;
   ] ;
   
   dr:transformation [
      dr:logicalData <#CountryLogicalData> ;
      dr:name "BusinessCountryTransformation";
      dr:parameterBinding [ 
         dr:parameterName "TEXT" ;
         rr:column "$.forretningsadresse.land" ;
      ]  ;
   ] ;
   
   dr:transformation [
      dr:logicalData <#PostCodeLogicalData> ;
      dr:name "BusinessPostCodeTransformation";
      dr:parameterBinding [ 
         dr:parameterName "COUNTRY" ;
         rr:constant "NO" ;
      ] ;
      dr:parameterBinding [ 
         dr:parameterName "POSTCODE" ;
         rr:column "$.forretningsadresse.postnummer" ;
         dr:condition [
            rr:column "$.forretningsadresse.postnummer" ;
            drop:neq "";
         ] ; 		 
      ]  ;
   ] ;
   
   dr:transformation [
      dr:logicalData <#NutsLogicalData> ;
      dr:name "BusinessNutsTransformation";
      dr:parameterBinding [ 
         dr:parameterName "TEXT" ;
         rr:column "BusinessPostCodeTransformation~~$.NUTS3" ;
      ]  ;
   ]  ;
				</code></pre>
			</code>
			
			</section>
			
			<section>
			<h3>Defined Columns</h3>

			Next, definitions of <a href="#dfn-defined-column">defined columns</a> are provided in order to extract the street number from the address (first and third defined column below). Because the <code>$.postadresse.adresse</code> and <code>$.forretningsadresse.adresse</code> logical columns are arrays of strings representing address parts, the elements of each array as obtained by the value map are then joined using the <a href="#dfn-join-string">join string</a> ", ", thereby providing the values for the defined columns with names <code>FULL_POSTAL_ADDRESS</code> and <code>FULL_BUSINESS_ADDRESS</code>. Then the street number is extracted from the values of the <code>FULL_POSTAL_ADDRESS</code> and <code>FULL_BUSINESS_ADDRESS</code> in the defined columns (defined second and fourth defined column below) with names <code>POSTAL_ADDRESS</code> and <code>BUSINESS_ADDRESS</code> which are generated by applying the <code>drop:extractMatch</code> function on those strings. The <code>regex</code> parameter is a regular expression with two capturing groups, hence the elements of <code>POSTAL_ADDRESS</code> and <code>BUSINESS_ADDRESS</code> can be referenced in <a href="#dfn-column-value-map">column value maps</a> and <a href="#dfn-template-value-map">template value maps</a> as <code>POSTAL_ADDRESS.match#1</code>, <code>POSTAL_ADDRESS.match#2</code>, and <code>BUSINESS_ADDRESS.match#1</code> and <code>BUSINESS_ADDRESS.match#2</code>.
			
			<div class="marker" id="ex-detailed-example-triples-map-defined-columns">
				<pre class="example" title="Conversion of business register data to RDF dataset: business register data triples map: defined columns."><code>
<#EnheterMapping>  
   dr:definedColumn [
      dr:name "FULL_POSTAL_ADDRESS" ;
      dr:function drop:identity ; 
      dr:parameterBinding [ 
         dr:parameterName "input" ;
         rr:column "$.postadresse.adresse" ;   
         dr:joinString ", " ;
      ] ;
   ] ;
   
   dr:definedColumn [
      dr:name "POSTAL_ADDRESS" ;
      dr:function drop:extractMatch ; 
      dr:parameterBinding [ 
         dr:parameterName "input" ;
         rr:column "FULL_POSTAL_ADDRESS" ;   
      ] ;
      dr:parameterBinding [ 
         dr:parameterName "regex" ;
         rr:constant "^(.*?)(?:\\s+([0-9]+\\s?[A-Z]?))?$"  ;
      ] ; 
   ] ;
   
   dr:definedColumn [
      dr:name "FULL_BUSINESS_ADDRESS" ;
      dr:function drop:identity ; 
      dr:parameterBinding [ 
         dr:parameterName "input" ;
         rr:column "$.forretningsadresse.adresse" ;   
         dr:joinString ", " ;
      ] ;
   ] ;
   
   dr:definedColumn [
      dr:name "BUSINESS_ADDRESS" ;
      dr:function drop:extractMatch ; 
      dr:parameterBinding [ 
         dr:parameterName "input" ;
         rr:column "FULL_BUSINESS_ADDRESS" ;   
      ] ;
      dr:parameterBinding [ 
         dr:parameterName "regex" ;
         rr:constant "^(.*?)(?:\\s+([0-9]+\\s?[A-Z]?))?$"  ;
      ] ; 
   ] ;   
				</code></pre>
			</div>
			
			</section>
		
			<section>
			<h3>Subject Map</h3>

			<p>Next, the <a href="#dfn-subject-map">subject map</a> definition follows. It is a <a href="#dfn-template-value-map">template value map</a>; note the reference to the <code>sd-organization-no</code> namespace by writting <code>{@sd-organization-no}</code> in the <a href="#dfn-string-template">string template</a>.</p>
			
			<div class="marker" id="ex-detailed-example-enheter-json">
				<pre class="example" title="Conversion of business register data to RDF dataset: business register data triples map: subject map."><code>   
<#EnheterMapping>  
   rr:subjectMap [ 
      rr:template  "{@sd-organization-no}{$.organisasjonsnummer}" ;
      rr:class legal:LegalEntity ;
   ] ;
				</code></pre>
			</code>
			
			</section>
			
			<section>
			<h3>Predicate Object Maps</h3>

			<p>Next, the <a href="#dfn-predicate-object-map">predicate object maps</a> definitions follow.</p>
			
			<div class="marker" id="ex-detailed-example-predicate-object-maps">
				<pre class="example" title="Conversion of business register data to RDF dataset: business register data triples map: predicate object maps."><code>   
<#EnheterMapping>  

   # Company name
   rr:predicateObjectMap [ 
      rr:predicate  legal:legalName ;
      rr:objectMap  [ 
         rr:column "$.navn" ;
         rr:termType  rr:Literal ;
         rr:language "no" ;
      ] ;
   ] ;   
   
   # Legal form
   rr:predicateObjectMap [ 
      rr:predicate  legal:companyType ;
      rr:objectMap  [ 
         rr:template "{@sd-legalform-code-no}{$.organisasjonsform.kode}" ;
         rr:termType  rr:IRI ;
      ] ;
   ] ;

   # Main activity
   rr:predicateObjectMap [
      rr:predicate legal:companyActivity, sd-model:mainActivity ;
      rr:objectMap [
         rr:template "{@nace-code-no}{$.naeringskode1.kode}" ;
         rr:termType rr:IRI ;
         dr:condition [
            rr:column "$.naeringskode1.kode" ;
            drop:neq "00.000" ;
         ] ;
      ] ;
      rr:objectMap [
         rr:template "{@nace-code-no}{$.naeringskode2.kode}" ;
         rr:termType rr:IRI ;
         dr:condition [
            rr:column "$.naeringskode2.kode" ;
            drop:neq "00.000" ;
         ] ;
      ] ;
      rr:objectMap [
         rr:template "{@nace-code-no}{$.naeringskode3.kode}" ;
         rr:termType rr:IRI ;
         dr:condition [
            rr:column "$.naeringskode3.kode" ;
            drop:neq "00.000" ;
         ] ;
      ] ;
   ]  ;
   
   # Auxiliary activity
   rr:predicateObjectMap [
      rr:constant sd-model:auxiliaryActivity ;
      rr:objectMap [
         rr:template "{@nace-code-no}{$.hjelpeenhetskode.kode}" ;
         rr:termType rr:IRI ;
         dr:condition [
            rr:column "$.hjelpeenhetskode.kode" ;
            drop:neq "00.000" ;
         ] ;
      ] ;
   ]  ;

   # Website
   rr:predicateObjectMap [ 
      rr:predicate  schema:url ;
      rr:objectMap  [ 
         rr:column "$.hjemmeside" ;
         rr:datatype  xsd:anyURI ;
      ] ;      
   ] ;  
   
   # Creation date
   rr:predicateObjectMap [ 
      rr:predicate  dcterms:modified ;
      rr:objectMap [
         rr:constant "{@@DATE@@}" ;
         rr:datatype xsd:dateTime;
      ] ;   
   ] ;
   
   # THIRD PARTY WEBPAGES 
   rr:predicateObjectMap [ 
      rr:predicate  owl:sameAs ;
      rr:objectMap  [ 
         rr:template "https://data.brreg.no/enhetsregisteret/oppslag/enheter/{$.organisasjonsnummer}" ;
         rr:termType rr:IRI ;
      ] ;
   ] ;      
   
   # FOUNDATION DATE (if explicitly given used it, else use registration date)
   rr:predicateObjectMap [ 
      rr:predicate  schema:foundingDate ;
      rr:objectMap  [ 
         dr:cases ( [
            rr:column "$.stiftelsesdato" ;
            rr:datatype xsd:date ;
            dr:condition [
               rr:column "$.stiftelsesdato" ;
               drop:neq "";
            ] ;
         ] [
            rr:column "$.registreringsdatoEnhetsregisteret" ;
            rr:datatype xsd:date ;
         ] )
      ] ;      
   ] ;   
   
   # BRREG REGISTRATION IDENTIFIER
   rr:predicateObjectMap [
      rr:predicate legal:legalIdentifier ;
      rr:objectMap [
         rr:parentTriplesMap [
            rr:subjectMap [
               rr:template "{@sd-identifier-no}brreg/{$.organisasjonsnummer}" ;
               rr:class adms:Identifier ;
            ] ;

            # DATE ISSUED
            rr:predicateObjectMap [
               rr:predicate dcterms:issued;
               rr:objectMap [
                  rr:column "$.registreringsdatoEnhetsregisteret" ;
                  rr:datatype xsd:date;
               ] ;
            ] ;

            # REGISTRATION NUMBER 
            rr:predicateObjectMap [
               rr:predicate skos:notation;
               rr:objectMap [
                  rr:column "$.organisasjonsnummer" ;
                  rr:termType rr:Literal;
               ] ;
            ] ;

            # ISSUING BODY
            rr:predicateObjectMap [
               rr:predicate dcterms:creator;
               rr:objectMap [
                  rr:constant sd-agency-no:brreg ;
               ] ;
            ] ;
         ] ;
      ] ;
   ] ;   

   rr:predicateObjectMap [ 
      rr:predicateMap [  
         rr:constant sd-model:postalAddress;
         dr:condition [
            rr:column "$.postadresse.landkode" ;
            drop:neq "";
         ] ;
      ] ;    
      rr:predicateMap [  
         rr:constant legal:registeredAddress;
         dr:condition [
            rr:column "$.postadresse.landkode" ;
            drop:neq "";
         ] ;
      ] ;    
      rr:objectMap [
         rr:parentTriplesMap [
            rr:subjectMap [
               rr:template "{@sd-address-no}{$.organisasjonsnummer}/p";
               rr:class locn:Address ;
            ] ;

            rr:predicateObjectMap [ 
               rr:predicate  locn:thoroughfare ;
               rr:objectMap  [ 
                  rr:column "POSTAL_ADDRESS.match#1" ;
                  rr:termType  rr:Literal ;
               ] ;      
            ] ;   

            rr:predicateObjectMap [ 
               rr:predicate  locn:locatorDesignator ;
               rr:objectMap  [ 
                  rr:column "POSTAL_ADDRESS.match#2" ;
                  rr:termType  rr:Literal ;
               ] ;      
            ] ;   

            rr:predicateObjectMap [ 
               rr:predicate  locn:fullAddress ;
               rr:objectMap  [ 
                  rr:language  "no" ;
                  dr:cases ( [
                     rr:template  "<<{FULL_POSTAL_ADDRESS}, >>{$.postadresse.poststed}, {$.postadresse.land}" ;
                     rr:termType  rr:Literal ;
                     dr:condition [
                        rr:column  "$.postadresse.landkode" ;
                        drop:neq "NO" ;
                     ] ;
                  ] [
                     rr:template  "<<{FULL_POSTAL_ADDRESS}, >>{$.postadresse.postnummer} {$.postadresse.poststed}, {$.postadresse.land}" ;
                     rr:termType  rr:Literal ;
                     dr:condition [
                        rr:column  "$.postadresse.landkode" ;
                        drop:eq "NO" ;
                     ] ;     
                  ] ) ;
                ] ; 
                rr:objectMap  [ 
                   rr:language  "en" ;
                   dr:cases ( [
                      rr:template  "<<{FULL_POSTAL_ADDRESS}, >>{$.postadresse.poststed}, {PostalCountryTransformation~~countryEngLabel}" ;
                      rr:termType  rr:Literal ;
                      dr:condition [
                         rr:column  "$.postadresse.landkode" ;
                         drop:neq "NO" ;
                      ] ;
                   ] [
                      rr:template  "<<{FULL_POSTAL_ADDRESS}, >>{$.postadresse.postnummer} {$.postadresse.poststed}, {PostalCountryTransformation~~countryEngLabel}" ;
                      rr:termType  rr:Literal ;
                      dr:condition [
                         rr:column  "$.postadresse.landkode" ;
                         drop:eq "NO" ;
                      ] ;
                   ] ) ;
                ] ; 
            ] ;   

            rr:predicateObjectMap [ 
               rr:predicate  locn:postCode ;
               rr:objectMap  [ 
                  rr:column "$.postadresse.postnummer" ;
                  rr:termType  rr:Literal ;
               ] ;      
            ] ;   
            rr:predicateObjectMap [ 
               rr:predicate  locn:postName ;
               rr:objectMap  [ 
                  rr:column "$.postadresse.poststed" ;
                  rr:termType  rr:Literal ;
                  dr:condition [
                     rr:column  "$.postadresse.landkode" ;
                     drop:eq "NO" ;
                  ] ;                          
                ] ;      
            ] ;   
            rr:predicateObjectMap [ 
               rr:predicate  locn:adminUnitL1 ;
               rr:objectMap  [ 
                  rr:column "$.postadresse.landkode" ;
                  rr:termType  rr:Literal ;
                ] ;      
            ] ;   
            rr:predicateObjectMap [ 
               rr:predicate  locn:adminUnitL2 ;
               rr:objectMap  [ 
                  rr:column "$.postadresse.kommune" ;
                  rr:termType  rr:Literal ;
               ] ;      
            ] ;                     
            rr:predicateObjectMap [ 
               rr:predicate  sd-model:country ;
               rr:objectMap  [ 
                  rr:column "PostalCountryTransformation~~$.r2-uri[0]" ;
                  rr:termType  rr:IRI ;
               ] ;      
            ] ;   
            rr:predicateObjectMap [ 
               rr:predicate  sd-model:nuts3 ;
               rr:objectMap  [ 
                  rr:template "{@nuts-code}{PostalPostCodeTransformation~~$.NUTS3}" ;
                  rr:termType  rr:IRI ;
               ] ;      
            ] ;   
            rr:predicateObjectMap [ 
               rr:predicate  sd-model:lau ;
               rr:objectMap  [ 
                  rr:template "{@lau-code}{PostalPostCodeTransformation~~$.LAU}" ;
                  rr:termType  rr:IRI ;
               ] ;      
            ] ;
         ] ;   
      ] ;
   ] ;

   rr:predicateObjectMap [ 
      rr:predicateMap [  
         rr:constant legal:registeredAddress;
         dr:condition [
            rr:column "$.forretningsadresse.landkode" ;
            drop:neq "";
         ] ;
      ] ;    
      rr:predicateMap [  
         rr:constant sd-model:businessAddress;
         dr:condition [
            rr:column "$.forretningsadresse.landkode" ;
            drop:neq "";
         ] ;
      ] ;    
      rr:objectMap [
         rr:parentTriplesMap [
            rr:subjectMap [
               rr:template "{@sd-address-no}{$.organisasjonsnummer}/b" ;
               rr:class locn:Address ;
            ] ;

            rr:predicateObjectMap [ 
               rr:predicate  locn:thoroughfare ;
               rr:objectMap  [ 
                  rr:column "BUSINESS_ADDRESS.match#1" ;
                  rr:termType  rr:Literal ;
               ] ;      
            ] ;   

            rr:predicateObjectMap [ 
               rr:predicate  locn:locatorDesignator ;
               rr:objectMap  [ 
                  rr:column "BUSINESS_ADDRESS.match#2" ;
                  rr:termType  rr:Literal ;
               ] ;      
            ] ;   

            rr:predicateObjectMap [ 
               rr:predicate  locn:fullAddress ;
               rr:objectMap  [ 
                  rr:language  "no" ;
                  dr:cases ( [
                     rr:template  "<<{FULL_BUSINESS_ADDRESS}, >>{$.forretningsadresse.poststed}, {$.forretningsadresse.land}" ;
                     rr:termType  rr:Literal ;
                     dr:condition [
                        rr:column  "$.forretningsadresse.landkode" ;
                        drop:neq "NO" ;
                     ] ;
                  ] [
                     rr:template  "<<{FULL_BUSINESS_ADDRESS}, >>{$.forretningsadresse.postnummer} {$.forretningsadresse.poststed}, {$.forretningsadresse.land}" ;
                     rr:termType  rr:Literal ;
                     dr:condition [
                        rr:column  "$.forretningsadresse.landkode" ;
                        drop:eq "NO" ;
                     ] ;     
                  ] ) ;
               ] ; 
               rr:objectMap  [ 
                  rr:language  "en" ;
                  dr:cases ( [
                     rr:template  "<<{FULL_BUSINESS_ADDRESS}, >>{$.forretningsadresse.poststed}, {BusinessCountryTransformation~~countryEngLabel}" ;
                     rr:termType  rr:Literal ;
                     dr:condition [
                        rr:column  "$.forretningsadresse.landkode" ;
                        drop:neq "NO" ;
                     ] ;
                  ] [
                     rr:template  "<<{FULL_BUSINESS_ADDRESS}, >>{$.forretningsadresse.postnummer} {$.forretningsadresse.poststed}, {BusinessCountryTransformation~~countryEngLabel}" ;
                     rr:termType  rr:Literal ;
                     dr:condition [
                        rr:column  "$.forretningsadresse.landkode" ;
                        drop:eq "NO" ;
                     ] ;
                  ] ) ;
               ] ; 
            ] ;   

            rr:predicateObjectMap [ 
               rr:predicate  locn:postCode ;
               rr:objectMap  [ 
                  rr:column "$.forretningsadresse.postnummer" ;
                  rr:termType  rr:Literal ;
               ] ;      
            ] ;   
   
            rr:predicateObjectMap [ 
               rr:predicate  locn:postName ;
               rr:objectMap  [ 
               rr:column "$.forretningsadresse.poststed" ;
                  rr:termType  rr:Literal ;
                  dr:condition [
                     rr:column  "$.forretningsadresse.landkode" ;
                     drop:eq "NO" ;
                  ] ;                          
               ] ;      
            ] ;   
           
            rr:predicateObjectMap [ 
               rr:predicate  locn:adminUnitL1 ;
               rr:objectMap  [ 
                  rr:column "$.forretningsadresse.landkode" ;
                  rr:termType  rr:Literal ;
               ] ;      
            ] ;   
                    
            rr:predicateObjectMap [ 
               rr:predicate  locn:adminUnitL2 ;
               rr:objectMap  [ 
                  rr:column "$.forretningsadresse.kommune" ;
                  rr:termType  rr:Literal ;
               ] ;      
            ] ;                     

            rr:predicateObjectMap [ 
               rr:predicate  sd-model:country ;
               rr:objectMap  [ 
                  rr:column "BusinessCountryTransformation~~$.r2-uri[0]" ;
                  rr:termType  rr:IRI ;
               ] ;      
            ] ;   
       
            rr:predicateObjectMap [ 
               rr:predicate  sd-model:nuts3 ;
               rr:objectMap  [ 
                  rr:template "{@nuts-code}{BusinessPostCodeTransformation~~$.NUTS3}" ;
                  rr:termType  rr:IRI ;
               ] ;      
            ] ;   

            rr:predicateObjectMap [ 
               rr:predicate  sd-model:lau ;
               rr:objectMap  [ 
                  rr:template "{@lau-code}{BusinessPostCodeTransformation~~$.LAU}" ;
                  rr:termType  rr:IRI ;
               ] ;      
            ] ;
          ];
      ] ;
   ] ;
				</code></pre>
			</div>
			
		</section>
		
		</section>
		
		<section>
			<h3>D2RML Document</h3>
			
			<p>Finally, the D2RML document contains a <a href="#dfn-d2rml-document">D2RML document</a> element. Although not necessary since the document contains only one triples map, it specifies the triples map that the <a href="#dfn-d2rml-processor">D2RML processor</a> should execute. It also declares that the D2RML document is parametric, and depends upon an external parameter with name <code>DATE</code> that should be provided by the runtime environment to the <a href="#dfn-d2rml-processor">D2RML processor</a>.</p>
			
			<div class="marker" id="ex-detailed-example-d2rml-document">
				<pre class="example" title="Conversion of business register data to RDF dataset: business register data D2RML document element."><code>
<#Document>
   a dr:D2RMLDocument ;
   dr:logicalDatasets ( <#EnheterMapping> ) .
   dr:parameter [
      a dr:ExternalParameter ;
      dr:name "DATE" ;
   ] ;
				</code></pre>
			</div>

		</section>
	</section>
</body>

</html>
